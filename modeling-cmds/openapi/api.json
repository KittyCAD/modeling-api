{
  "openapi": "3.0.3",
  "info": {
    "title": "Example Modeling API server",
    "description": "Example modeling API server",
    "contact": {
      "url": "https://zoo.dev",
      "email": "api@zoo.dev"
    },
    "version": "1.2.3"
  },
  "paths": {
    "/example": {
      "put": {
        "operationId": "example",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebSocketRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Angle": {
        "description": "An angle, with a specific unit.",
        "type": "object",
        "properties": {
          "unit": {
            "description": "What unit is the measurement?",
            "allOf": [
              {
                "$ref": "#/components/schemas/UnitAngle"
              }
            ]
          },
          "value": {
            "description": "The size of the angle, measured in the chosen unit.",
            "type": "number",
            "format": "double"
          }
        },
        "required": [
          "unit",
          "value"
        ]
      },
      "AnnotationBasicDimension": {
        "description": "Parameters for defining an MBD Basic Dimension Annotation state which is measured between two positions in 3D",
        "type": "object",
        "properties": {
          "dimension": {
            "description": "Basic dimension parameters (symbol and tolerance)",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationMbdBasicDimension"
              }
            ]
          },
          "font_point_size": {
            "description": "The point size of the fonts used to generate the annotation label.  Very large values can negatively affect performance.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "font_scale": {
            "description": "The scale of the font label in 3D space",
            "type": "number",
            "format": "float"
          },
          "from_entity_id": {
            "description": "Entity to measure the dimension from",
            "type": "string",
            "format": "uuid"
          },
          "from_entity_pos": {
            "description": "Normalized position within the entity to position the dimension from",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point2d"
              }
            ]
          },
          "offset": {
            "description": "2D Position offset of the annotation within the plane.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point2d"
              }
            ]
          },
          "plane_id": {
            "description": "Orientation plane.  The annotation will lie in this plane which is positioned about the leader position as its origin.",
            "type": "string",
            "format": "uuid"
          },
          "precision": {
            "description": "Number of decimal places to use when displaying tolerance and dimension values",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "to_entity_id": {
            "description": "Entity to measure the dimension to",
            "type": "string",
            "format": "uuid"
          },
          "to_entity_pos": {
            "description": "Normalized position within the entity to position the dimension to",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point2d"
              }
            ]
          }
        },
        "required": [
          "dimension",
          "font_point_size",
          "font_scale",
          "from_entity_id",
          "from_entity_pos",
          "offset",
          "plane_id",
          "precision",
          "to_entity_id",
          "to_entity_pos"
        ]
      },
      "AnnotationFeatureControl": {
        "description": "Parameters for defining an MBD Feature Control Annotation state",
        "type": "object",
        "properties": {
          "control_frame": {
            "nullable": true,
            "description": "MBD Control frame for geometric control",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationMbdControlFrame"
              }
            ]
          },
          "defined_datum": {
            "nullable": true,
            "description": "Set if this annotation is defining a datum",
            "type": "string",
            "minLength": 1,
            "maxLength": 1
          },
          "dimension": {
            "nullable": true,
            "description": "Basic dimensions",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationMbdBasicDimension"
              }
            ]
          },
          "entity_id": {
            "description": "Entity to place the annotation leader from",
            "type": "string",
            "format": "uuid"
          },
          "entity_pos": {
            "description": "Normalized position within the entity to position the annotation leader from",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point2d"
              }
            ]
          },
          "font_point_size": {
            "description": "The point size of the fonts used to generate the annotation label.  Very large values can negatively affect performance.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "font_scale": {
            "description": "The scale of the font label in 3D space",
            "type": "number",
            "format": "float"
          },
          "leader_type": {
            "description": "Type of leader to use",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationLineEnd"
              }
            ]
          },
          "offset": {
            "description": "2D Position offset of the annotation within the plane.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point2d"
              }
            ]
          },
          "plane_id": {
            "description": "Orientation plane.  The annotation will lie in this plane which is positioned about the leader position as its origin.",
            "type": "string",
            "format": "uuid"
          },
          "precision": {
            "description": "Number of decimal places to use when displaying tolerance and dimension values",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "prefix": {
            "nullable": true,
            "description": "Prefix text which will appear before the basic dimension",
            "type": "string"
          },
          "suffix": {
            "nullable": true,
            "description": "Suffix text which will appear after the basic dimension",
            "type": "string"
          }
        },
        "required": [
          "entity_id",
          "entity_pos",
          "font_point_size",
          "font_scale",
          "leader_type",
          "offset",
          "plane_id",
          "precision"
        ]
      },
      "AnnotationFeatureTag": {
        "description": "Parameters for defining an MBD Feature Tag Annotation state",
        "type": "object",
        "properties": {
          "entity_id": {
            "description": "Entity to place the annotation leader from",
            "type": "string",
            "format": "uuid"
          },
          "entity_pos": {
            "description": "Normalized position within the entity to position the annotation leader from",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point2d"
              }
            ]
          },
          "font_point_size": {
            "description": "The point size of the fonts used to generate the annotation label.  Very large values can negatively affect performance.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "font_scale": {
            "description": "The scale of the font label in 3D space",
            "type": "number",
            "format": "float"
          },
          "key": {
            "description": "Tag key",
            "type": "string"
          },
          "leader_type": {
            "description": "Type of leader to use",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationLineEnd"
              }
            ]
          },
          "offset": {
            "description": "2D Position offset of the annotation within the plane.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point2d"
              }
            ]
          },
          "plane_id": {
            "description": "Orientation plane.  The annotation will lie in this plane which is positioned about the leader position as its origin.",
            "type": "string",
            "format": "uuid"
          },
          "show_key": {
            "description": "Whether or not to display the key on the annotation label",
            "type": "boolean"
          },
          "value": {
            "description": "Tag value",
            "type": "string"
          }
        },
        "required": [
          "entity_id",
          "entity_pos",
          "font_point_size",
          "font_scale",
          "key",
          "leader_type",
          "offset",
          "plane_id",
          "show_key",
          "value"
        ]
      },
      "AnnotationLineEnd": {
        "description": "Annotation line end type",
        "type": "string",
        "enum": [
          "none",
          "arrow",
          "dot"
        ]
      },
      "AnnotationLineEndOptions": {
        "description": "Options for annotation text",
        "type": "object",
        "properties": {
          "end": {
            "description": "How to style the end of the annotation line.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationLineEnd"
              }
            ]
          },
          "start": {
            "description": "How to style the start of the annotation line.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationLineEnd"
              }
            ]
          }
        },
        "required": [
          "end",
          "start"
        ]
      },
      "AnnotationMbdBasicDimension": {
        "description": "Parameters for defining an MBD basic dimension",
        "type": "object",
        "properties": {
          "dimension": {
            "nullable": true,
            "description": "The explicitly defined dimension.  Only required if the measurement is not automatically calculated.",
            "type": "number",
            "format": "double"
          },
          "symbol": {
            "nullable": true,
            "description": "Type of symbol to use for this dimension (if required)",
            "allOf": [
              {
                "$ref": "#/components/schemas/MbdSymbol"
              }
            ]
          },
          "tolerance": {
            "description": "The tolerance of the dimension",
            "type": "number",
            "format": "double"
          }
        },
        "required": [
          "tolerance"
        ]
      },
      "AnnotationMbdControlFrame": {
        "description": "Parameters for defining an MBD Geometric control frame",
        "type": "object",
        "properties": {
          "diameter_symbol": {
            "nullable": true,
            "description": "Diameter symbol (if required) whether the geometric control requires a cylindrical or diameter tolerance",
            "allOf": [
              {
                "$ref": "#/components/schemas/MbdSymbol"
              }
            ]
          },
          "modifier": {
            "nullable": true,
            "description": "Feature of size or tolerance modifiers",
            "allOf": [
              {
                "$ref": "#/components/schemas/MbdSymbol"
              }
            ]
          },
          "primary_datum": {
            "nullable": true,
            "description": "Primary datum",
            "type": "string",
            "minLength": 1,
            "maxLength": 1
          },
          "secondary_datum": {
            "nullable": true,
            "description": "Secondary datum",
            "type": "string",
            "minLength": 1,
            "maxLength": 1
          },
          "symbol": {
            "description": "Geometric symbol, the type of geometric control specified",
            "allOf": [
              {
                "$ref": "#/components/schemas/MbdSymbol"
              }
            ]
          },
          "tertiary_datum": {
            "nullable": true,
            "description": "Tertiary datum",
            "type": "string",
            "minLength": 1,
            "maxLength": 1
          },
          "tolerance": {
            "description": "Tolerance value - the total tolerance of the geometric control.  The unit is based on the drawing standard.",
            "type": "number",
            "format": "double"
          }
        },
        "required": [
          "symbol",
          "tolerance"
        ]
      },
      "AnnotationOptions": {
        "description": "Options for annotations",
        "type": "object",
        "properties": {
          "color": {
            "nullable": true,
            "description": "Color to render the annotation",
            "allOf": [
              {
                "$ref": "#/components/schemas/Color"
              }
            ]
          },
          "dimension": {
            "nullable": true,
            "description": "Set as an MBD measured basic dimension annotation",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationBasicDimension"
              }
            ]
          },
          "feature_control": {
            "nullable": true,
            "description": "Set as an MBD Feature control annotation",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationFeatureControl"
              }
            ]
          },
          "feature_tag": {
            "nullable": true,
            "description": "Set as a feature tag annotation",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationFeatureTag"
              }
            ]
          },
          "line_ends": {
            "nullable": true,
            "description": "How to style the start and end of the line",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationLineEndOptions"
              }
            ]
          },
          "line_width": {
            "nullable": true,
            "description": "Width of the annotation's line",
            "type": "number",
            "format": "float"
          },
          "position": {
            "nullable": true,
            "description": "Position to put the annotation",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point3d"
              }
            ]
          },
          "text": {
            "nullable": true,
            "description": "Text displayed on the annotation",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationTextOptions"
              }
            ]
          }
        }
      },
      "AnnotationTextAlignmentX": {
        "description": "Horizontal Text alignment",
        "type": "string",
        "enum": [
          "left",
          "center",
          "right"
        ]
      },
      "AnnotationTextAlignmentY": {
        "description": "Vertical Text alignment",
        "type": "string",
        "enum": [
          "bottom",
          "center",
          "top"
        ]
      },
      "AnnotationTextOptions": {
        "description": "Options for annotation text",
        "type": "object",
        "properties": {
          "point_size": {
            "description": "Text font's point size",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "text": {
            "description": "Text displayed on the annotation",
            "type": "string"
          },
          "x": {
            "description": "Alignment along the X axis",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationTextAlignmentX"
              }
            ]
          },
          "y": {
            "description": "Alignment along the Y axis",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnnotationTextAlignmentY"
              }
            ]
          }
        },
        "required": [
          "point_size",
          "text",
          "x",
          "y"
        ]
      },
      "AnnotationType": {
        "description": "The type of annotation",
        "oneOf": [
          {
            "description": "2D annotation type (screen or planar space)",
            "type": "string",
            "enum": [
              "t2d"
            ]
          },
          {
            "description": "3D annotation type",
            "type": "string",
            "enum": [
              "t3d"
            ]
          }
        ]
      },
      "Axis": {
        "description": "Co-ordinate axis specifier.\n\nSee [cglearn.eu] for background reading.\n\n[cglearn.eu]: https://cglearn.eu/pub/computer-graphics/introduction-to-geometry#material-coordinate-systems-1",
        "oneOf": [
          {
            "description": "'Y' axis.",
            "type": "string",
            "enum": [
              "y"
            ]
          },
          {
            "description": "'Z' axis.",
            "type": "string",
            "enum": [
              "z"
            ]
          }
        ]
      },
      "AxisDirectionPair": {
        "description": "An [`Axis`] paired with a [`Direction`].",
        "type": "object",
        "properties": {
          "axis": {
            "description": "Axis specifier.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Axis"
              }
            ]
          },
          "direction": {
            "description": "Specifies which direction the axis is pointing.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Direction"
              }
            ]
          }
        },
        "required": [
          "axis",
          "direction"
        ]
      },
      "CameraDragInteractionType": {
        "description": "The type of camera drag interaction.",
        "oneOf": [
          {
            "description": "Camera pan",
            "type": "string",
            "enum": [
              "pan"
            ]
          },
          {
            "description": "Camera rotate (spherical camera revolve/orbit)",
            "type": "string",
            "enum": [
              "rotate"
            ]
          },
          {
            "description": "Camera rotate (trackball with 3 degrees of freedom)",
            "type": "string",
            "enum": [
              "rotatetrackball"
            ]
          },
          {
            "description": "Camera zoom (increase or decrease distance to reference point center)",
            "type": "string",
            "enum": [
              "zoom"
            ]
          }
        ]
      },
      "CameraMovement": {
        "description": "A type of camera movement applied after certain camera operations",
        "oneOf": [
          {
            "description": "Adjusts the camera position during the camera operation",
            "type": "string",
            "enum": [
              "vantage"
            ]
          },
          {
            "description": "Keeps the camera position in place",
            "type": "string",
            "enum": [
              "none"
            ]
          }
        ]
      },
      "CameraViewState": {
        "type": "object",
        "properties": {
          "eye_offset": {
            "type": "number",
            "format": "float"
          },
          "fov_y": {
            "type": "number",
            "format": "float"
          },
          "is_ortho": {
            "type": "boolean"
          },
          "ortho_scale_enabled": {
            "type": "boolean"
          },
          "ortho_scale_factor": {
            "type": "number",
            "format": "float"
          },
          "pivot_position": {
            "$ref": "#/components/schemas/Point3d"
          },
          "pivot_rotation": {
            "$ref": "#/components/schemas/Point4d"
          },
          "world_coord_system": {
            "$ref": "#/components/schemas/WorldCoordinateSystem"
          }
        },
        "required": [
          "eye_offset",
          "fov_y",
          "is_ortho",
          "ortho_scale_enabled",
          "ortho_scale_factor",
          "pivot_position",
          "pivot_rotation",
          "world_coord_system"
        ]
      },
      "ClientMetrics": {
        "description": "ClientMetrics contains information regarding the state of the peer.",
        "type": "object",
        "properties": {
          "rtc_frame_height": {
            "nullable": true,
            "description": "The height of the inbound video stream in pixels.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-frameheight",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "rtc_frame_width": {
            "nullable": true,
            "description": "The width of the inbound video stream in pixels.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-framewidth",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "rtc_frames_decoded": {
            "nullable": true,
            "description": "Counter of the number of WebRTC frames that the client has decoded from the inbound video stream.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-freezecount",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "rtc_frames_dropped": {
            "nullable": true,
            "description": "Counter of the number of WebRTC frames the client has dropped from the inbound video stream.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-framesdropped",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "rtc_frames_per_second": {
            "nullable": true,
            "description": "Current number of frames being rendered in the last second. A good target is 60 frames per second, but it can fluctuate depending on network conditions.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-freezecount",
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "rtc_frames_received": {
            "nullable": true,
            "description": "Counter of the number of WebRTC frames that the client has received from the inbound video stream.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-freezecount",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "rtc_freeze_count": {
            "nullable": true,
            "description": "Number of times the inbound video playback has frozen. This is usually due to network conditions.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-freezecount",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "rtc_jitter_sec": {
            "nullable": true,
            "description": "Amount of \"jitter\" in the inbound video stream. Network latency is the time it takes a packet to traverse the network. The amount that the latency varies is the jitter. Video latency is the time it takes to render a frame sent by the server (including network latency). A low jitter means the video latency can be reduced without impacting smooth playback. High jitter means clients will increase video latency to ensure smooth playback.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcreceivedrtpstreamstats-jitter",
            "type": "number",
            "format": "double"
          },
          "rtc_keyframes_decoded": {
            "nullable": true,
            "description": "Number of \"key frames\" decoded in the inbound h.264 stream. A key frame is an expensive (bandwidth-wise) \"full image\" of the video frame. Data after the keyframe become -- effectively -- \"diff\" operations on that key frame. The Engine will only send a keyframe if required, which is an indication that some of the \"diffs\" have been lost, usually an indication of poor network conditions. We like this metric to understand times when the connection has had to recover.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-keyframesdecoded",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "rtc_packets_lost": {
            "nullable": true,
            "description": "Amount of packets lost in the inbound video stream.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcreceivedrtpstreamstats-packetslost",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "rtc_pause_count": {
            "nullable": true,
            "description": "Count of the total number of video pauses experienced by this receiver.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-pausecount",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "rtc_pli_count": {
            "nullable": true,
            "description": "Count the total number of Picture Loss Indication (PLI) packets.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-plicount",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "rtc_stun_rtt_sec": {
            "nullable": true,
            "description": "Total duration of pauses in seconds.\n\nThis is the \"ping\" between the client and the STUN server. Not to be confused with the E2E RTT documented [here](https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats-roundtriptime)\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcicecandidatepairstats-currentroundtriptime",
            "type": "number",
            "format": "float"
          },
          "rtc_total_freezes_duration_sec": {
            "nullable": true,
            "description": "Number of seconds of frozen video the user has been subjected to.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-totalfreezesduration",
            "type": "number",
            "format": "float"
          },
          "rtc_total_pauses_duration_sec": {
            "nullable": true,
            "description": "Count of the total number of video pauses experienced by this receiver.\n\nhttps://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-totalpausesduration",
            "type": "number",
            "format": "float"
          }
        }
      },
      "Color": {
        "description": "An RGBA color",
        "type": "object",
        "properties": {
          "a": {
            "description": "Alpha",
            "type": "number",
            "format": "float"
          },
          "b": {
            "description": "Blue",
            "type": "number",
            "format": "float"
          },
          "g": {
            "description": "Green",
            "type": "number",
            "format": "float"
          },
          "r": {
            "description": "Red",
            "type": "number",
            "format": "float"
          }
        },
        "required": [
          "a",
          "b",
          "g",
          "r"
        ]
      },
      "ComponentTransform": {
        "description": "Container that holds a translate, rotate and scale. Defaults to no change, everything stays the same (i.e. the identity function).",
        "type": "object",
        "properties": {
          "rotate_angle_axis": {
            "nullable": true,
            "description": "Rotate component of the transform. The rotation is specified as an axis and an angle (xyz are the components of the axis, w is the angle in degrees).",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransformByForPoint4d"
              }
            ]
          },
          "rotate_rpy": {
            "nullable": true,
            "description": "Rotate component of the transform. The rotation is specified as a roll, pitch, yaw.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransformByForPoint3d"
              }
            ]
          },
          "scale": {
            "nullable": true,
            "description": "Scale component of the transform.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransformByForPoint3d"
              }
            ]
          },
          "translate": {
            "nullable": true,
            "description": "Translate component of the transform.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransformByForPoint3d"
              }
            ]
          }
        }
      },
      "CutStrategy": {
        "description": "What strategy (algorithm) should be used for cutting? Defaults to Automatic.",
        "oneOf": [
          {
            "description": "Basic fillet cut. This has limitations, like the filletted edges can't touch each other. But it's very fast and simple.",
            "type": "string",
            "enum": [
              "basic"
            ]
          },
          {
            "description": "More complicated fillet cut. It works for more use-cases, like edges that touch each other. But it's slower than the Basic method.",
            "type": "string",
            "enum": [
              "csg"
            ]
          },
          {
            "description": "Tries the Basic method, and if that doesn't work, tries the CSG strategy.",
            "type": "string",
            "enum": [
              "automatic"
            ]
          }
        ]
      },
      "CutType": {
        "description": "What kind of cut to do",
        "oneOf": [
          {
            "description": "Round off an edge.",
            "type": "string",
            "enum": [
              "fillet"
            ]
          },
          {
            "description": "Cut away an edge.",
            "type": "string",
            "enum": [
              "chamfer"
            ]
          }
        ]
      },
      "CutTypeV2": {
        "description": "What kind of cut to perform when cutting an edge.",
        "oneOf": [
          {
            "description": "Round off an edge.",
            "type": "object",
            "properties": {
              "fillet": {
                "type": "object",
                "properties": {
                  "radius": {
                    "description": "The radius of the fillet.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/LengthUnit"
                      }
                    ]
                  },
                  "second_length": {
                    "nullable": true,
                    "description": "The second length affects the edge length of the second face of the cut. This will cause the fillet to take on the shape of a conic section, instead of an arc.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/LengthUnit"
                      }
                    ]
                  }
                },
                "required": [
                  "radius"
                ]
              }
            },
            "required": [
              "fillet"
            ],
            "additionalProperties": false
          },
          {
            "description": "Cut away an edge.",
            "type": "object",
            "properties": {
              "chamfer": {
                "type": "object",
                "properties": {
                  "angle": {
                    "nullable": true,
                    "description": "The angle of the chamfer, default is 45deg.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/Angle"
                      }
                    ]
                  },
                  "distance": {
                    "description": "The distance from the edge to cut on each face.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/LengthUnit"
                      }
                    ]
                  },
                  "second_distance": {
                    "nullable": true,
                    "description": "The second distance affects the edge length of the second face of the cut.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/LengthUnit"
                      }
                    ]
                  },
                  "swap": {
                    "description": "If true, the second distance or angle is applied to the other face of the cut.",
                    "type": "boolean"
                  }
                },
                "required": [
                  "distance",
                  "swap"
                ]
              }
            },
            "required": [
              "chamfer"
            ],
            "additionalProperties": false
          },
          {
            "description": "A custom cut profile.",
            "type": "object",
            "properties": {
              "custom": {
                "type": "object",
                "properties": {
                  "path": {
                    "description": "The path that will be used for the custom profile.",
                    "type": "string",
                    "format": "uuid"
                  }
                },
                "required": [
                  "path"
                ]
              }
            },
            "required": [
              "custom"
            ],
            "additionalProperties": false
          }
        ]
      },
      "Direction": {
        "description": "Specifies the sign of a co-ordinate axis.",
        "oneOf": [
          {
            "description": "Increasing numbers.",
            "type": "string",
            "enum": [
              "positive"
            ]
          },
          {
            "description": "Decreasing numbers.",
            "type": "string",
            "enum": [
              "negative"
            ]
          }
        ]
      },
      "DistanceType": {
        "description": "The type of distance Distances can vary depending on the objects used as input.",
        "oneOf": [
          {
            "description": "Euclidean Distance.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "euclidean"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "The distance between objects along the specified axis",
            "type": "object",
            "properties": {
              "axis": {
                "description": "Global axis",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GlobalAxis"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "on_axis"
                ]
              }
            },
            "required": [
              "axis",
              "type"
            ]
          }
        ]
      },
      "DxfStorage": {
        "description": "Export storage.",
        "oneOf": [
          {
            "description": "Plaintext encoding.\n\nThis is the default setting.",
            "type": "string",
            "enum": [
              "ascii"
            ]
          },
          {
            "description": "Binary encoding.",
            "type": "string",
            "enum": [
              "binary"
            ]
          }
        ]
      },
      "EntityType": {
        "description": "The type of entity",
        "type": "string",
        "enum": [
          "entity",
          "object",
          "path",
          "curve",
          "solid2d",
          "solid3d",
          "edge",
          "face",
          "plane",
          "vertex"
        ]
      },
      "Error": {
        "description": "Error information from a response.",
        "type": "object",
        "properties": {
          "error_code": {
            "type": "string"
          },
          "message": {
            "type": "string"
          },
          "request_id": {
            "type": "string"
          }
        },
        "required": [
          "message",
          "request_id"
        ]
      },
      "ExtrudeMethod": {
        "description": "Extrusion method determining if the extrusion will be part of the existing object or an entirely new object.",
        "oneOf": [
          {
            "description": "Create a new object that is not connected to the object it is extruded from. This will result in two objects after the operation.",
            "type": "string",
            "enum": [
              "new"
            ]
          },
          {
            "description": "This extrusion will be part of object it is extruded from. This will result in one object after the operation.",
            "type": "string",
            "enum": [
              "merge"
            ]
          }
        ]
      },
      "ExtrudeReference": {
        "description": "Type of reference geometry to extrude to.",
        "oneOf": [
          {
            "description": "Extrudes along the normal of the top face until it is as close to the entity as possible. An entity can be a solid, a path, a face, etc.",
            "type": "object",
            "properties": {
              "entity_reference": {
                "type": "object",
                "properties": {
                  "entity_id": {
                    "description": "The UUID of the entity to extrude to.",
                    "type": "string",
                    "format": "uuid"
                  }
                },
                "required": [
                  "entity_id"
                ]
              }
            },
            "required": [
              "entity_reference"
            ],
            "additionalProperties": false
          },
          {
            "description": "Extrudes until the top face is as close as possible to this given axis.",
            "type": "object",
            "properties": {
              "axis": {
                "type": "object",
                "properties": {
                  "axis": {
                    "description": "The axis to extrude to.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/Point3d"
                      }
                    ]
                  },
                  "point": {
                    "description": "Point the axis goes through. Defaults to (0, 0, 0).",
                    "default": {
                      "x": 0.0,
                      "y": 0.0,
                      "z": 0.0
                    },
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/Point3d"
                      }
                    ]
                  }
                },
                "required": [
                  "axis"
                ]
              }
            },
            "required": [
              "axis"
            ],
            "additionalProperties": false
          },
          {
            "description": "Extrudes until the top face is as close as possible to this given point.",
            "type": "object",
            "properties": {
              "point": {
                "type": "object",
                "properties": {
                  "point": {
                    "description": "The point to extrude to.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/Point3d"
                      }
                    ]
                  }
                },
                "required": [
                  "point"
                ]
              }
            },
            "required": [
              "point"
            ],
            "additionalProperties": false
          }
        ]
      },
      "ExtrudedFaceInfo": {
        "description": "IDs for the extruded faces.",
        "type": "object",
        "properties": {
          "bottom": {
            "nullable": true,
            "description": "The face made from the original 2D shape being extruded. If the solid is extruded from a shape which already has an ID (e.g. extruding something which was sketched on a face), this doesn't need to be sent.",
            "type": "string",
            "format": "uuid"
          },
          "sides": {
            "description": "Any intermediate sides between the top and bottom.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SideFace"
            }
          },
          "top": {
            "description": "Top face of the extrusion (parallel and further away from the original 2D shape being extruded).",
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "sides",
          "top"
        ]
      },
      "FbxStorage": {
        "description": "Describes the storage format of an FBX file.",
        "oneOf": [
          {
            "description": "ASCII FBX encoding.",
            "type": "string",
            "enum": [
              "ascii"
            ]
          },
          {
            "description": "Binary FBX encoding.",
            "type": "string",
            "enum": [
              "binary"
            ]
          }
        ]
      },
      "GlobalAxis": {
        "description": "The global axes.",
        "oneOf": [
          {
            "description": "The X axis",
            "type": "string",
            "enum": [
              "x"
            ]
          },
          {
            "description": "The Y axis",
            "type": "string",
            "enum": [
              "y"
            ]
          },
          {
            "description": "The Z axis",
            "type": "string",
            "enum": [
              "z"
            ]
          }
        ]
      },
      "GltfPresentation": {
        "description": "Describes the presentation style of the glTF JSON.",
        "oneOf": [
          {
            "description": "Condense the JSON into the smallest possible size.",
            "type": "string",
            "enum": [
              "compact"
            ]
          },
          {
            "description": "Expand the JSON into a more human readable format.\n\nThis is the default setting.",
            "type": "string",
            "enum": [
              "pretty"
            ]
          }
        ]
      },
      "GltfStorage": {
        "description": "Describes the storage format of a glTF 2.0 scene.",
        "oneOf": [
          {
            "description": "Binary glTF 2.0.\n\nThis is a single binary with .glb extension.",
            "type": "string",
            "enum": [
              "binary"
            ]
          },
          {
            "description": "Standard glTF 2.0.\n\nThis is a JSON file with .gltf extension paired with a separate binary blob file with .bin extension.",
            "type": "string",
            "enum": [
              "standard"
            ]
          },
          {
            "description": "Embedded glTF 2.0.\n\nSingle JSON file with .gltf extension binary data encoded as base64 data URIs.\n\nThis is the default setting.",
            "type": "string",
            "enum": [
              "embedded"
            ]
          }
        ]
      },
      "ImageFormat": {
        "description": "Enum containing the variety of image formats snapshots may be exported to.",
        "oneOf": [
          {
            "description": ".png format",
            "type": "string",
            "enum": [
              "png"
            ]
          },
          {
            "description": ".jpeg format",
            "type": "string",
            "enum": [
              "jpeg"
            ]
          }
        ]
      },
      "ImportFile": {
        "description": "File to import into the current model. If you are sending binary data for a file, be sure to send the WebSocketRequest as binary/bson, not text/json.",
        "type": "object",
        "properties": {
          "data": {
            "description": "The raw bytes of the file",
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0
            }
          },
          "path": {
            "description": "The file's full path, including file extension.",
            "type": "string"
          }
        },
        "required": [
          "data",
          "path"
        ]
      },
      "InputFormat3d": {
        "description": "Input format specifier.",
        "oneOf": [
          {
            "description": "Autodesk Filmbox (FBX) format.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "fbx"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Binary glTF 2.0. We refer to this as glTF since that is how our customers refer to it, but this can also import binary glTF (glb).",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "gltf"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Wavefront OBJ format.",
            "type": "object",
            "properties": {
              "coords": {
                "description": "Co-ordinate system of input data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/System"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "obj"
                ]
              },
              "units": {
                "description": "The units of the input data.\n\nThis is very important for correct scaling and when calculating physics properties like mass, etc.\n\nDefaults to millimeters.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitLength"
                  }
                ]
              }
            },
            "required": [
              "coords",
              "type",
              "units"
            ]
          },
          {
            "description": "The PLY Polygon File Format.",
            "type": "object",
            "properties": {
              "coords": {
                "description": "Co-ordinate system of input data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/System"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "ply"
                ]
              },
              "units": {
                "description": "The units of the input data.\n\nThis is very important for correct scaling and when calculating physics properties like mass, etc.\n\nDefaults to millimeters.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitLength"
                  }
                ]
              }
            },
            "required": [
              "coords",
              "type",
              "units"
            ]
          },
          {
            "description": "SolidWorks part (SLDPRT) format.",
            "type": "object",
            "properties": {
              "split_closed_faces": {
                "description": "Splits all closed faces into two open faces.\n\nDefaults to `false` but is implicitly `true` when importing into the engine.",
                "default": false,
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "sldprt"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "ISO 10303-21 (STEP) format.",
            "type": "object",
            "properties": {
              "split_closed_faces": {
                "description": "Splits all closed faces into two open faces.\n\nDefaults to `false` but is implicitly `true` when importing into the engine.",
                "default": false,
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "step"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "*ST**ereo**L**ithography format.",
            "type": "object",
            "properties": {
              "coords": {
                "description": "Co-ordinate system of input data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/System"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "stl"
                ]
              },
              "units": {
                "description": "The units of the input data.\n\nThis is very important for correct scaling and when calculating physics properties like mass, etc.\n\nDefaults to millimeters.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitLength"
                  }
                ]
              }
            },
            "required": [
              "coords",
              "type",
              "units"
            ]
          }
        ]
      },
      "LengthUnit": {
        "type": "number",
        "format": "double"
      },
      "MbdSymbol": {
        "description": "MBD symbol type",
        "type": "string",
        "enum": [
          "none",
          "arclength",
          "between",
          "degrees",
          "plusminus",
          "angularity",
          "cylindricity",
          "roundness",
          "concentricity",
          "straightness",
          "parallelism",
          "flatness",
          "profileofline",
          "surfaceprofile",
          "symmetry",
          "perpendicularity",
          "runout",
          "totalrunout",
          "position",
          "centerline",
          "partingline",
          "isoenvelope",
          "isoenvelopenony145m",
          "freestate",
          "statisticaltolerance",
          "continuousfeature",
          "independency",
          "depth",
          "start",
          "leastcondition",
          "maxcondition",
          "conicaltaper",
          "projected",
          "slope",
          "micro",
          "tangentplane",
          "unilateral",
          "squarefeature",
          "countersink",
          "spotface",
          "target",
          "diameter",
          "radius",
          "sphericalradius",
          "sphericaldiameter",
          "controlledradius",
          "boxstart",
          "boxbar",
          "boxbarbetween",
          "letterbackwardunderline",
          "punctuationbackwardunderline",
          "modifierbackwardunderline",
          "numericbackwardunderline",
          "boxend",
          "datumup",
          "datumleft",
          "datumright",
          "datumdown",
          "datumtriangle",
          "halfspace",
          "quarterspace",
          "eighthspace",
          "modifierspace"
        ]
      },
      "ModelingCmd": {
        "description": "Commands that the KittyCAD engine can execute.",
        "oneOf": [
          {
            "description": "Evaluates the position of a path in one shot (engine utility for kcl executor)",
            "type": "object",
            "properties": {
              "path_json": {
                "description": "The path in json form (the serialized result of the kcl Sketch/Path object",
                "type": "string"
              },
              "t": {
                "description": "The evaluation parameter (path curve parameter in the normalized domain [0, 1])",
                "type": "number",
                "format": "double"
              },
              "type": {
                "type": "string",
                "enum": [
                  "engine_util_evaluate_path"
                ]
              }
            },
            "required": [
              "path_json",
              "t",
              "type"
            ]
          },
          {
            "description": "Start a new path.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "start_path"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Move the path's \"pen\". If you're in sketch mode, these coordinates are in the local coordinate system, not the world's coordinate system. For example, say you're sketching on the plane {x: (1,0,0), y: (0,1,0), origin: (0, 0, 50)}. In other words, the plane 50 units above the default XY plane. Then, moving the pen to (1, 1, 0) with this command uses local coordinates. So, it would move the pen to (1, 1, 50) in global coordinates.",
            "type": "object",
            "properties": {
              "path": {
                "description": "The ID of the command which created the path.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "to": {
                "description": "Where the path's pen should be.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "move_path_pen"
                ]
              }
            },
            "required": [
              "path",
              "to",
              "type"
            ]
          },
          {
            "description": "Extend a path by adding a new segment which starts at the path's \"pen\". If no \"pen\" location has been set before (via `MovePen`), then the pen is at the origin.",
            "type": "object",
            "properties": {
              "label": {
                "nullable": true,
                "description": "Optional label to associate with the new path segment.",
                "type": "string"
              },
              "path": {
                "description": "The ID of the command which created the path.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "segment": {
                "description": "Segment to append to the path. This segment will implicitly begin at the current \"pen\" location.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PathSegment"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "extend_path"
                ]
              }
            },
            "required": [
              "path",
              "segment",
              "type"
            ]
          },
          {
            "description": "Command for extruding a solid 2d.",
            "type": "object",
            "properties": {
              "distance": {
                "description": "How far off the plane to extrude",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "extrude_method": {
                "description": "Should the extrusion create a new object or be part of the existing object.",
                "default": "merge",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExtrudeMethod"
                  }
                ]
              },
              "faces": {
                "nullable": true,
                "description": "Which IDs should the new faces have? If this isn't given, the engine will generate IDs.",
                "default": null,
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExtrudedFaceInfo"
                  }
                ]
              },
              "opposite": {
                "description": "Should the extrusion also extrude in the opposite direction? If so, this specifies its distance.",
                "default": "None",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/OppositeForLengthUnit"
                  }
                ]
              },
              "target": {
                "description": "Which sketch to extrude. Must be a closed 2D solid.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "extrude"
                ]
              }
            },
            "required": [
              "distance",
              "target",
              "type"
            ]
          },
          {
            "description": "Command for extruding a solid 2d to a reference geometry.",
            "type": "object",
            "properties": {
              "extrude_method": {
                "description": "Should the extrusion create a new object or be part of the existing object.",
                "default": "merge",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExtrudeMethod"
                  }
                ]
              },
              "faces": {
                "nullable": true,
                "description": "Which IDs should the new faces have? If this isn't given, the engine will generate IDs.",
                "default": null,
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExtrudedFaceInfo"
                  }
                ]
              },
              "reference": {
                "description": "Reference to extrude to. Extrusion occurs along the target's normal until it is as close to the reference as possible.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExtrudeReference"
                  }
                ]
              },
              "target": {
                "description": "Which sketch to extrude. Must be a closed 2D solid.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "extrude_to_reference"
                ]
              }
            },
            "required": [
              "reference",
              "target",
              "type"
            ]
          },
          {
            "description": "Command for twist extruding a solid 2d.",
            "type": "object",
            "properties": {
              "angle_step_size": {
                "description": "Angle step interval (converted to whole number degrees and bounded between 4 and 90)",
                "default": {
                  "unit": "degrees",
                  "value": 15.0
                },
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "center_2d": {
                "description": "Center to twist about (relative to 2D sketch)",
                "default": {
                  "x": 0.0,
                  "y": 0.0
                },
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              },
              "distance": {
                "description": "How far off the plane to extrude",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "faces": {
                "nullable": true,
                "description": "Which IDs should the new faces have? If this isn't given, the engine will generate IDs.",
                "default": null,
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExtrudedFaceInfo"
                  }
                ]
              },
              "target": {
                "description": "Which sketch to extrude. Must be a closed 2D solid.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "tolerance": {
                "description": "The twisted surface loft tolerance",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "total_rotation_angle": {
                "description": "Total rotation of the section",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "twist_extrude"
                ]
              }
            },
            "required": [
              "distance",
              "target",
              "tolerance",
              "total_rotation_angle",
              "type"
            ]
          },
          {
            "description": "Extrude the object along a path.",
            "type": "object",
            "properties": {
              "relative_to": {
                "description": "What is this sweep relative to?",
                "default": "sketch_plane",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelativeTo"
                  }
                ]
              },
              "sectional": {
                "description": "If true, the sweep will be broken up into sub-sweeps (extrusions, revolves, sweeps) based on the trajectory path components.",
                "type": "boolean"
              },
              "target": {
                "description": "Which sketch to sweep. Must be a closed 2D solid.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "tolerance": {
                "description": "The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero).",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "trajectory": {
                "description": "Path along which to sweep.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "sweep"
                ]
              }
            },
            "required": [
              "sectional",
              "target",
              "tolerance",
              "trajectory",
              "type"
            ]
          },
          {
            "description": "Command for revolving a solid 2d.",
            "type": "object",
            "properties": {
              "angle": {
                "description": "The signed angle of revolution (in degrees, must be <= 360 in either direction)",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "axis": {
                "description": "The axis of the extrusion (taken from the origin)",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "axis_is_2d": {
                "description": "If true, the axis is interpreted within the 2D space of the solid 2D's plane",
                "type": "boolean"
              },
              "opposite": {
                "description": "Should the revolution also revolve in the opposite direction along the given axis? If so, this specifies its angle.",
                "default": "None",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/OppositeForAngle"
                  }
                ]
              },
              "origin": {
                "description": "The origin of the extrusion axis",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "target": {
                "description": "Which sketch to revolve. Must be a closed 2D solid.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "tolerance": {
                "description": "The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero).",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "revolve"
                ]
              }
            },
            "required": [
              "angle",
              "axis",
              "axis_is_2d",
              "origin",
              "target",
              "tolerance",
              "type"
            ]
          },
          {
            "description": "Command for shelling a solid3d face",
            "type": "object",
            "properties": {
              "face_ids": {
                "description": "Which faces to remove, leaving only the shell.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "hollow": {
                "description": "If true, the Solid3D is made hollow instead of removing the selected faces",
                "default": false,
                "type": "boolean"
              },
              "object_id": {
                "description": "Which Solid3D is being shelled.",
                "type": "string",
                "format": "uuid"
              },
              "shell_thickness": {
                "description": "How thick the shell should be. Smaller values mean a thinner shell.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_shell_face"
                ]
              }
            },
            "required": [
              "face_ids",
              "object_id",
              "shell_thickness",
              "type"
            ]
          },
          {
            "description": "Command for revolving a solid 2d about a brep edge",
            "type": "object",
            "properties": {
              "angle": {
                "description": "The signed angle of revolution (in degrees, must be <= 360 in either direction)",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "edge_id": {
                "description": "The edge to use as the axis of revolution, must be linear and lie in the plane of the solid",
                "type": "string",
                "format": "uuid"
              },
              "opposite": {
                "description": "Should the revolution also revolve in the opposite direction along the given axis? If so, this specifies its angle.",
                "default": "None",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/OppositeForAngle"
                  }
                ]
              },
              "target": {
                "description": "Which sketch to revolve. Must be a closed 2D solid.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "tolerance": {
                "description": "The maximum acceptable surface gap computed between the revolution surface joints. Must be positive (i.e. greater than zero).",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "revolve_about_edge"
                ]
              }
            },
            "required": [
              "angle",
              "edge_id",
              "target",
              "tolerance",
              "type"
            ]
          },
          {
            "description": "Command for lofting sections to create a solid",
            "type": "object",
            "properties": {
              "base_curve_index": {
                "nullable": true,
                "description": "This can be set to override the automatically determined topological base curve, which is usually the first section encountered.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "bez_approximate_rational": {
                "description": "Attempt to approximate rational curves (such as arcs) using a bezier. This will remove banding around interpolations between arcs and non-arcs.  It may produce errors in other scenarios Over time, this field won't be necessary.",
                "type": "boolean"
              },
              "section_ids": {
                "description": "The closed section curves to create a lofted solid from. Currently, these must be Solid2Ds",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "tolerance": {
                "description": "Tolerance",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "loft"
                ]
              },
              "v_degree": {
                "description": "Degree of the interpolation. Must be greater than zero. For example, use 2 for quadratic, or 3 for cubic interpolation in the V direction.",
                "type": "integer",
                "format": "uint32",
                "minimum": 1
              }
            },
            "required": [
              "bez_approximate_rational",
              "section_ids",
              "tolerance",
              "type",
              "v_degree"
            ]
          },
          {
            "description": "Closes a path, converting it to a 2D solid.",
            "type": "object",
            "properties": {
              "path_id": {
                "description": "Which path to close.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "close_path"
                ]
              }
            },
            "required": [
              "path_id",
              "type"
            ]
          },
          {
            "description": "Camera drag started.",
            "type": "object",
            "properties": {
              "interaction": {
                "description": "The type of camera drag interaction.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CameraDragInteractionType"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "camera_drag_start"
                ]
              },
              "window": {
                "description": "The initial mouse position.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "interaction",
              "type",
              "window"
            ]
          },
          {
            "description": "Camera drag continued.",
            "type": "object",
            "properties": {
              "interaction": {
                "description": "The type of camera drag interaction.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CameraDragInteractionType"
                  }
                ]
              },
              "sequence": {
                "nullable": true,
                "description": "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "camera_drag_move"
                ]
              },
              "window": {
                "description": "The current mouse position.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "interaction",
              "type",
              "window"
            ]
          },
          {
            "description": "Camera drag ended",
            "type": "object",
            "properties": {
              "interaction": {
                "description": "The type of camera drag interaction.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CameraDragInteractionType"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "camera_drag_end"
                ]
              },
              "window": {
                "description": "The final mouse position.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "interaction",
              "type",
              "window"
            ]
          },
          {
            "description": "Gets the default camera's camera settings",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_get_settings"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Gets the default camera's view state",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_get_view"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Sets the default camera's view state",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_set_view"
                ]
              },
              "view": {
                "description": "Camera view state",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CameraViewState"
                  }
                ]
              }
            },
            "required": [
              "type",
              "view"
            ]
          },
          {
            "description": "Change what the default camera is looking at.",
            "type": "object",
            "properties": {
              "center": {
                "description": "What the camera is looking at. Center of the camera's field of vision",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "sequence": {
                "nullable": true,
                "description": "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_look_at"
                ]
              },
              "up": {
                "description": "Which way is \"up\", from the camera's point of view.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "vantage": {
                "description": "Where the camera is positioned",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              }
            },
            "required": [
              "center",
              "type",
              "up",
              "vantage"
            ]
          },
          {
            "description": "Change what the default camera is looking at.",
            "type": "object",
            "properties": {
              "center": {
                "description": "What the camera is looking at. Center of the camera's field of vision",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "fov_y": {
                "nullable": true,
                "description": "The field of view angle in the y direction, in degrees.",
                "type": "number",
                "format": "float"
              },
              "sequence": {
                "nullable": true,
                "description": "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_perspective_settings"
                ]
              },
              "up": {
                "description": "Which way is \"up\", from the camera's point of view.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "vantage": {
                "description": "Where the camera is positioned",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "z_far": {
                "nullable": true,
                "description": "The distance to the far clipping plane.",
                "type": "number",
                "format": "float"
              },
              "z_near": {
                "nullable": true,
                "description": "The distance to the near clipping plane.",
                "type": "number",
                "format": "float"
              }
            },
            "required": [
              "center",
              "type",
              "up",
              "vantage"
            ]
          },
          {
            "description": "Adjust zoom of the default camera.",
            "type": "object",
            "properties": {
              "magnitude": {
                "description": "Move the camera forward along the vector it's looking at, by this magnitudedefaultCameraZoom. Basically, how much should the camera move forward by.",
                "type": "number",
                "format": "float"
              },
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_zoom"
                ]
              }
            },
            "required": [
              "magnitude",
              "type"
            ]
          },
          {
            "description": "Export a sketch to a file.",
            "type": "object",
            "properties": {
              "entity_ids": {
                "description": "IDs of the entities to be exported.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "format": {
                "description": "The file format to export to.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/OutputFormat2d"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "export2d"
                ]
              }
            },
            "required": [
              "entity_ids",
              "format",
              "type"
            ]
          },
          {
            "description": "Export the scene to a file.",
            "type": "object",
            "properties": {
              "entity_ids": {
                "description": "IDs of the entities to be exported. If this is empty, then all entities are exported.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "format": {
                "description": "The file format to export to.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/OutputFormat3d"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "export3d"
                ]
              }
            },
            "required": [
              "entity_ids",
              "format",
              "type"
            ]
          },
          {
            "description": "Export the scene to a file.",
            "type": "object",
            "properties": {
              "entity_ids": {
                "description": "IDs of the entities to be exported. If this is empty, then all entities are exported.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "format": {
                "description": "The file format to export to.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/OutputFormat3d"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "export"
                ]
              }
            },
            "required": [
              "entity_ids",
              "format",
              "type"
            ]
          },
          {
            "description": "What is this entity's parent?",
            "type": "object",
            "properties": {
              "entity_id": {
                "description": "ID of the entity being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_get_parent_id"
                ]
              }
            },
            "required": [
              "entity_id",
              "type"
            ]
          },
          {
            "description": "How many children does the entity have?",
            "type": "object",
            "properties": {
              "entity_id": {
                "description": "ID of the entity being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_get_num_children"
                ]
              }
            },
            "required": [
              "entity_id",
              "type"
            ]
          },
          {
            "description": "What is the UUID of this entity's n-th child?",
            "type": "object",
            "properties": {
              "child_index": {
                "description": "Index into the entity's list of children.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "entity_id": {
                "description": "ID of the entity being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_get_child_uuid"
                ]
              }
            },
            "required": [
              "child_index",
              "entity_id",
              "type"
            ]
          },
          {
            "description": "What are all UUIDs of this entity's children?",
            "type": "object",
            "properties": {
              "entity_id": {
                "description": "ID of the entity being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_get_all_child_uuids"
                ]
              }
            },
            "required": [
              "entity_id",
              "type"
            ]
          },
          {
            "description": "What are all UUIDs of all the paths sketched on top of this entity?",
            "type": "object",
            "properties": {
              "entity_id": {
                "description": "ID of the entity being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_get_sketch_paths"
                ]
              }
            },
            "required": [
              "entity_id",
              "type"
            ]
          },
          {
            "description": "What is the distance between these two entities?",
            "type": "object",
            "properties": {
              "distance_type": {
                "description": "Type of distance to be measured.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/DistanceType"
                  }
                ]
              },
              "entity_id1": {
                "description": "ID of the first entity being queried.",
                "type": "string",
                "format": "uuid"
              },
              "entity_id2": {
                "description": "ID of the second entity being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_get_distance"
                ]
              }
            },
            "required": [
              "distance_type",
              "entity_id1",
              "entity_id2",
              "type"
            ]
          },
          {
            "description": "Create a pattern using this entity by specifying the transform for each desired repetition. Transformations are performed in the following order (first applied to last applied): scale, rotate, translate.",
            "type": "object",
            "properties": {
              "entity_id": {
                "description": "ID of the entity being cloned.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_clone"
                ]
              }
            },
            "required": [
              "entity_id",
              "type"
            ]
          },
          {
            "description": "Create a pattern using this entity by specifying the transform for each desired repetition. Transformations are performed in the following order (first applied to last applied): scale, rotate, translate.",
            "type": "object",
            "properties": {
              "entity_id": {
                "description": "ID of the entity being copied.",
                "type": "string",
                "format": "uuid"
              },
              "transform": {
                "description": "How to transform each repeated solid. The 0th transform will create the first copy of the entity. The total number of (optional) repetitions equals the size of this list.",
                "default": [],
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Transform"
                }
              },
              "transforms": {
                "description": "Alternatively, you could set this key instead. If you want to use multiple transforms per item. If this is non-empty then the `transform` key must be empty, and vice-versa.",
                "default": [],
                "type": "array",
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Transform"
                  }
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_linear_pattern_transform"
                ]
              }
            },
            "required": [
              "entity_id",
              "type"
            ]
          },
          {
            "description": "Create a linear pattern using this entity.",
            "type": "object",
            "properties": {
              "axis": {
                "description": "Axis along which to make the copies. For Solid2d patterns, the z component is ignored.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "entity_id": {
                "description": "ID of the entity being copied.",
                "type": "string",
                "format": "uuid"
              },
              "num_repetitions": {
                "description": "Number of repetitions to make.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "spacing": {
                "description": "Spacing between repetitions.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_linear_pattern"
                ]
              }
            },
            "required": [
              "axis",
              "entity_id",
              "num_repetitions",
              "spacing",
              "type"
            ]
          },
          {
            "description": "Create a circular pattern using this entity.",
            "type": "object",
            "properties": {
              "arc_degrees": {
                "description": "Arc angle (in degrees) to place repetitions along.",
                "type": "number",
                "format": "double"
              },
              "axis": {
                "description": "Axis around which to make the copies. For Solid2d patterns, this is ignored.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "center": {
                "description": "Point around which to make the copies. For Solid2d patterns, the z component is ignored.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "entity_id": {
                "description": "ID of the entity being copied.",
                "type": "string",
                "format": "uuid"
              },
              "num_repetitions": {
                "description": "Number of repetitions to make.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "rotate_duplicates": {
                "description": "Whether or not to rotate the objects as they are copied.",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_circular_pattern"
                ]
              }
            },
            "required": [
              "arc_degrees",
              "axis",
              "center",
              "entity_id",
              "num_repetitions",
              "rotate_duplicates",
              "type"
            ]
          },
          {
            "description": "Create a helix using the input cylinder and other specified parameters.",
            "type": "object",
            "properties": {
              "cylinder_id": {
                "description": "ID of the cylinder.",
                "type": "string",
                "format": "uuid"
              },
              "is_clockwise": {
                "description": "Is the helix rotation clockwise?",
                "type": "boolean"
              },
              "length": {
                "nullable": true,
                "description": "Length of the helix. If None, the length of the cylinder will be used instead.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "revolutions": {
                "description": "Number of revolutions.",
                "type": "number",
                "format": "double"
              },
              "start_angle": {
                "description": "Start angle.",
                "default": {
                  "unit": "degrees",
                  "value": 0.0
                },
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_make_helix"
                ]
              }
            },
            "required": [
              "cylinder_id",
              "is_clockwise",
              "revolutions",
              "type"
            ]
          },
          {
            "description": "Create a helix using the specified parameters.",
            "type": "object",
            "properties": {
              "axis": {
                "description": "Axis of the helix. The helix will be created around and in the direction of this axis.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "center": {
                "description": "Center of the helix at the base of the helix.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "is_clockwise": {
                "description": "Is the helix rotation clockwise?",
                "type": "boolean"
              },
              "length": {
                "description": "Length of the helix.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "radius": {
                "description": "Radius of the helix.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "revolutions": {
                "description": "Number of revolutions.",
                "type": "number",
                "format": "double"
              },
              "start_angle": {
                "description": "Start angle.",
                "default": {
                  "unit": "degrees",
                  "value": 0.0
                },
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_make_helix_from_params"
                ]
              }
            },
            "required": [
              "axis",
              "center",
              "is_clockwise",
              "length",
              "radius",
              "revolutions",
              "type"
            ]
          },
          {
            "description": "Create a helix using the specified parameters.",
            "type": "object",
            "properties": {
              "edge_id": {
                "description": "Edge about which to make the helix.",
                "type": "string",
                "format": "uuid"
              },
              "is_clockwise": {
                "description": "Is the helix rotation clockwise?",
                "type": "boolean"
              },
              "length": {
                "nullable": true,
                "description": "Length of the helix. If None, the length of the edge will be used instead.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "radius": {
                "description": "Radius of the helix.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "revolutions": {
                "description": "Number of revolutions.",
                "type": "number",
                "format": "double"
              },
              "start_angle": {
                "description": "Start angle.",
                "default": {
                  "unit": "degrees",
                  "value": 0.0
                },
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_make_helix_from_edge"
                ]
              }
            },
            "required": [
              "edge_id",
              "is_clockwise",
              "radius",
              "revolutions",
              "type"
            ]
          },
          {
            "description": "Mirror the input entities over the specified axis. (Currently only supports sketches)",
            "type": "object",
            "properties": {
              "axis": {
                "description": "Axis to use as mirror.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "ids": {
                "description": "ID of the mirror entities.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "point": {
                "description": "Point through which the mirror axis passes.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_mirror"
                ]
              }
            },
            "required": [
              "axis",
              "ids",
              "point",
              "type"
            ]
          },
          {
            "description": "Mirror the input entities over the specified edge. (Currently only supports sketches)",
            "type": "object",
            "properties": {
              "edge_id": {
                "description": "The edge to use as the mirror axis, must be linear and lie in the plane of the solid",
                "type": "string",
                "format": "uuid"
              },
              "ids": {
                "description": "ID of the mirror entities.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_mirror_across_edge"
                ]
              }
            },
            "required": [
              "edge_id",
              "ids",
              "type"
            ]
          },
          {
            "description": "Modifies the selection by simulating a \"mouse click\" at the given x,y window coordinate Returns ID of whatever was selected.",
            "type": "object",
            "properties": {
              "selected_at_window": {
                "description": "Where in the window was selected",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              },
              "selection_type": {
                "description": "What entity was selected?",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SceneSelectionType"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "select_with_point"
                ]
              }
            },
            "required": [
              "selected_at_window",
              "selection_type",
              "type"
            ]
          },
          {
            "description": "Adds one or more entities (by UUID) to the selection.",
            "type": "object",
            "properties": {
              "entities": {
                "description": "Which entities to select",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "select_add"
                ]
              }
            },
            "required": [
              "entities",
              "type"
            ]
          },
          {
            "description": "Removes one or more entities (by UUID) from the selection.",
            "type": "object",
            "properties": {
              "entities": {
                "description": "Which entities to unselect",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "select_remove"
                ]
              }
            },
            "required": [
              "entities",
              "type"
            ]
          },
          {
            "description": "Removes all of the Objects in the scene",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "scene_clear_all"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Replaces current selection with these entities (by UUID).",
            "type": "object",
            "properties": {
              "entities": {
                "description": "Which entities to select",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "select_replace"
                ]
              }
            },
            "required": [
              "entities",
              "type"
            ]
          },
          {
            "description": "Changes the current highlighted entity to whichever one is at the given window coordinate. If there's no entity at this location, clears the highlight.",
            "type": "object",
            "properties": {
              "selected_at_window": {
                "description": "Coordinates of the window being clicked",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              },
              "sequence": {
                "nullable": true,
                "description": "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "highlight_set_entity"
                ]
              }
            },
            "required": [
              "selected_at_window",
              "type"
            ]
          },
          {
            "description": "Changes the current highlighted entity to these entities.",
            "type": "object",
            "properties": {
              "entities": {
                "description": "Highlight these entities.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "highlight_set_entities"
                ]
              }
            },
            "required": [
              "entities",
              "type"
            ]
          },
          {
            "description": "Create a new annotation",
            "type": "object",
            "properties": {
              "annotation_type": {
                "description": "What type of annotation to create.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AnnotationType"
                  }
                ]
              },
              "clobber": {
                "description": "If true, any existing drawables within the obj will be replaced (the object will be reset)",
                "type": "boolean"
              },
              "options": {
                "description": "What should the annotation contain?",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AnnotationOptions"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "new_annotation"
                ]
              }
            },
            "required": [
              "annotation_type",
              "clobber",
              "options",
              "type"
            ]
          },
          {
            "description": "Update an annotation",
            "type": "object",
            "properties": {
              "annotation_id": {
                "description": "Which annotation to update",
                "type": "string",
                "format": "uuid"
              },
              "options": {
                "description": "If any of these fields are set, they will overwrite the previous options for the annotation.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AnnotationOptions"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "update_annotation"
                ]
              }
            },
            "required": [
              "annotation_id",
              "options",
              "type"
            ]
          },
          {
            "description": "Changes visibility of scene-wide edge lines on brep solids",
            "type": "object",
            "properties": {
              "hidden": {
                "description": "Whether or not the edge lines should be hidden.",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "edge_lines_visible"
                ]
              }
            },
            "required": [
              "hidden",
              "type"
            ]
          },
          {
            "description": "Hide or show an object",
            "type": "object",
            "properties": {
              "hidden": {
                "description": "Whether or not the object should be hidden.",
                "type": "boolean"
              },
              "object_id": {
                "description": "Which object to change",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "object_visible"
                ]
              }
            },
            "required": [
              "hidden",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Bring an object to the front of the scene",
            "type": "object",
            "properties": {
              "object_id": {
                "description": "Which object to change",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "object_bring_to_front"
                ]
              }
            },
            "required": [
              "object_id",
              "type"
            ]
          },
          {
            "description": "Set the material properties of an object",
            "type": "object",
            "properties": {
              "ambient_occlusion": {
                "description": "Ambient Occlusion of the new material",
                "type": "number",
                "format": "float"
              },
              "backface_color": {
                "nullable": true,
                "description": "Color of the backface",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Color"
                  }
                ]
              },
              "color": {
                "description": "Color of the new material",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Color"
                  }
                ]
              },
              "metalness": {
                "description": "Metalness of the new material",
                "type": "number",
                "format": "float"
              },
              "object_id": {
                "description": "Which object to change",
                "type": "string",
                "format": "uuid"
              },
              "roughness": {
                "description": "Roughness of the new material",
                "type": "number",
                "format": "float"
              },
              "type": {
                "type": "string",
                "enum": [
                  "object_set_material_params_pbr"
                ]
              }
            },
            "required": [
              "ambient_occlusion",
              "color",
              "metalness",
              "object_id",
              "roughness",
              "type"
            ]
          },
          {
            "description": "What type of entity is this?",
            "type": "object",
            "properties": {
              "entity_id": {
                "description": "ID of the entity being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "get_entity_type"
                ]
              }
            },
            "required": [
              "entity_id",
              "type"
            ]
          },
          {
            "description": "Gets all faces which use the given edge.",
            "type": "object",
            "properties": {
              "edge_id": {
                "description": "Which edge you want the faces of.",
                "type": "string",
                "format": "uuid"
              },
              "object_id": {
                "description": "Which object is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_get_all_edge_faces"
                ]
              }
            },
            "required": [
              "edge_id",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Add a hole to a Solid2d object before extruding it.",
            "type": "object",
            "properties": {
              "hole_id": {
                "description": "The id of the path to use as the inner profile (hole).",
                "type": "string",
                "format": "uuid"
              },
              "object_id": {
                "description": "Which object to add the hole to.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid2d_add_hole"
                ]
              }
            },
            "required": [
              "hole_id",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Gets all edges which are opposite the given edge, across all possible faces.",
            "type": "object",
            "properties": {
              "along_vector": {
                "nullable": true,
                "description": "If given, only faces parallel to this vector will be considered.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "edge_id": {
                "description": "Which edge you want the opposites of.",
                "type": "string",
                "format": "uuid"
              },
              "object_id": {
                "description": "Which object is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_get_all_opposite_edges"
                ]
              }
            },
            "required": [
              "edge_id",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Gets the edge opposite the given edge, along the given face.",
            "type": "object",
            "properties": {
              "edge_id": {
                "description": "Which edge you want the opposite of.",
                "type": "string",
                "format": "uuid"
              },
              "face_id": {
                "description": "Which face is used to figure out the opposite edge?",
                "type": "string",
                "format": "uuid"
              },
              "object_id": {
                "description": "Which object is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_get_opposite_edge"
                ]
              }
            },
            "required": [
              "edge_id",
              "face_id",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Gets the next adjacent edge for the given edge, along the given face.",
            "type": "object",
            "properties": {
              "edge_id": {
                "description": "Which edge you want the opposite of.",
                "type": "string",
                "format": "uuid"
              },
              "face_id": {
                "description": "Which face is used to figure out the opposite edge?",
                "type": "string",
                "format": "uuid"
              },
              "object_id": {
                "description": "Which object is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_get_next_adjacent_edge"
                ]
              }
            },
            "required": [
              "edge_id",
              "face_id",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Gets the previous adjacent edge for the given edge, along the given face.",
            "type": "object",
            "properties": {
              "edge_id": {
                "description": "Which edge you want the opposite of.",
                "type": "string",
                "format": "uuid"
              },
              "face_id": {
                "description": "Which face is used to figure out the opposite edge?",
                "type": "string",
                "format": "uuid"
              },
              "object_id": {
                "description": "Which object is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_get_prev_adjacent_edge"
                ]
              }
            },
            "required": [
              "edge_id",
              "face_id",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Gets the shared edge between these two faces if it exists",
            "type": "object",
            "properties": {
              "face_ids": {
                "description": "The faces being queried",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                },
                "minItems": 2,
                "maxItems": 2
              },
              "object_id": {
                "description": "Which object is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_get_common_edge"
                ]
              }
            },
            "required": [
              "face_ids",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Fillets the given edge with the specified radius.",
            "type": "object",
            "properties": {
              "cut_type": {
                "description": "How to apply the cut.",
                "default": "fillet",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CutType"
                  }
                ]
              },
              "edge_id": {
                "nullable": true,
                "description": "Which edge you want to fillet.",
                "default": null,
                "type": "string",
                "format": "uuid"
              },
              "edge_ids": {
                "description": "Which edges you want to fillet.",
                "default": [],
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "extra_face_ids": {
                "description": "What IDs should the resulting faces have? If you've only passed one edge ID, its ID will be the command ID used to send this command, and this field should be empty. If you've passed `n` IDs (to fillet `n` edges), then this should be length `n-1`, and the first edge will use the command ID used to send this command.",
                "default": [],
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "object_id": {
                "description": "Which object is being filletted.",
                "type": "string",
                "format": "uuid"
              },
              "radius": {
                "description": "The radius of the fillet. Measured in length (using the same units that the current sketch uses). Must be positive (i.e. greater than zero).",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "strategy": {
                "description": "Which cutting algorithm to use.",
                "default": "automatic",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CutStrategy"
                  }
                ]
              },
              "tolerance": {
                "description": "The maximum acceptable surface gap computed between the filleted surfaces. Must be positive (i.e. greater than zero).",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_fillet_edge"
                ]
              }
            },
            "required": [
              "object_id",
              "radius",
              "tolerance",
              "type"
            ]
          },
          {
            "description": "Cut the list of given edges with the given cut parameters.",
            "type": "object",
            "properties": {
              "cut_type": {
                "description": "The cut type and information required to perform the cut.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CutTypeV2"
                  }
                ]
              },
              "edge_ids": {
                "description": "Which edges you want to cut.",
                "default": [],
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "extra_face_ids": {
                "description": "What IDs should the resulting faces have? If you've only passed one edge ID, its ID will be the command ID used to send this command, and this field should be empty. If you've passed `n` IDs (to cut `n` edges), then this should be length `n-1`, and the first edge will use the command ID used to send this command.",
                "default": [],
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "object_id": {
                "description": "Which object is being cut.",
                "type": "string",
                "format": "uuid"
              },
              "strategy": {
                "description": "Which cutting algorithm to use.",
                "default": "automatic",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CutStrategy"
                  }
                ]
              },
              "tolerance": {
                "description": "The maximum acceptable surface gap computed between the cut surfaces. Must be positive (i.e. greater than zero).",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_cut_edges"
                ]
              }
            },
            "required": [
              "cut_type",
              "object_id",
              "tolerance",
              "type"
            ]
          },
          {
            "description": "Determines whether a brep face is planar and returns its surface-local planar axes if so",
            "type": "object",
            "properties": {
              "object_id": {
                "description": "Which face is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "face_is_planar"
                ]
              }
            },
            "required": [
              "object_id",
              "type"
            ]
          },
          {
            "description": "Determines a position on a brep face evaluated by parameters u,v",
            "type": "object",
            "properties": {
              "object_id": {
                "description": "Which face is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "face_get_position"
                ]
              },
              "uv": {
                "description": "The 2D parameter-space u,v position to evaluate the surface at",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "object_id",
              "type",
              "uv"
            ]
          },
          {
            "description": "Obtains the surface \"center of mass\"",
            "type": "object",
            "properties": {
              "object_id": {
                "description": "Which face is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "face_get_center"
                ]
              }
            },
            "required": [
              "object_id",
              "type"
            ]
          },
          {
            "description": "Determines the gradient (dFdu, dFdv) + normal vector on a brep face evaluated by parameters u,v",
            "type": "object",
            "properties": {
              "object_id": {
                "description": "Which face is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "face_get_gradient"
                ]
              },
              "uv": {
                "description": "The 2D parameter-space u,v position to evaluate the surface at",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "object_id",
              "type",
              "uv"
            ]
          },
          {
            "description": "Send object to front or back.",
            "type": "object",
            "properties": {
              "front": {
                "description": "Bring to front = true, send to back = false.",
                "type": "boolean"
              },
              "object_id": {
                "description": "Which object is being changed.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "send_object"
                ]
              }
            },
            "required": [
              "front",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Set opacity of the entity.",
            "type": "object",
            "properties": {
              "entity_id": {
                "description": "Which entity is being changed.",
                "type": "string",
                "format": "uuid"
              },
              "opacity": {
                "description": "How transparent should it be? 0 or lower is totally transparent. 1 or greater is totally opaque.",
                "type": "number",
                "format": "float"
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_set_opacity"
                ]
              }
            },
            "required": [
              "entity_id",
              "opacity",
              "type"
            ]
          },
          {
            "description": "Fade entity in or out.",
            "type": "object",
            "properties": {
              "duration_seconds": {
                "description": "How many seconds the animation should take.",
                "default": 0.4,
                "type": "number",
                "format": "double"
              },
              "entity_id": {
                "description": "Which entity is being changed.",
                "type": "string",
                "format": "uuid"
              },
              "fade_in": {
                "description": "Fade in = true, fade out = false.",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "entity_fade"
                ]
              }
            },
            "required": [
              "entity_id",
              "fade_in",
              "type"
            ]
          },
          {
            "description": "Make a new plane",
            "type": "object",
            "properties": {
              "clobber": {
                "description": "If true, any existing drawables within the obj will be replaced (the object will be reset)",
                "type": "boolean"
              },
              "hide": {
                "nullable": true,
                "description": "If true, the plane will be created but hidden initially.",
                "type": "boolean"
              },
              "origin": {
                "description": "Origin of the plane",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "size": {
                "description": "What should the plane's span/extent? When rendered visually, this is both the width and height along X and Y axis respectively.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "make_plane"
                ]
              },
              "x_axis": {
                "description": "What should the plane's X axis be?",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "y_axis": {
                "description": "What should the plane's Y axis be?",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              }
            },
            "required": [
              "clobber",
              "origin",
              "size",
              "type",
              "x_axis",
              "y_axis"
            ]
          },
          {
            "description": "Set the color of a plane.",
            "type": "object",
            "properties": {
              "color": {
                "description": "What color it should be.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Color"
                  }
                ]
              },
              "plane_id": {
                "description": "Which plane is being changed.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "plane_set_color"
                ]
              }
            },
            "required": [
              "color",
              "plane_id",
              "type"
            ]
          },
          {
            "description": "Set the current tool.",
            "type": "object",
            "properties": {
              "tool": {
                "description": "What tool should be active.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SceneToolType"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "set_tool"
                ]
              }
            },
            "required": [
              "tool",
              "type"
            ]
          },
          {
            "description": "Send a mouse move event",
            "type": "object",
            "properties": {
              "sequence": {
                "nullable": true,
                "description": "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "mouse_move"
                ]
              },
              "window": {
                "description": "Where the mouse is",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "type",
              "window"
            ]
          },
          {
            "description": "Send a mouse click event Updates modified/selected entities.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "mouse_click"
                ]
              },
              "window": {
                "description": "Where the mouse is",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "type",
              "window"
            ]
          },
          {
            "description": "Disable sketch mode. If you are sketching on a face, be sure to not disable sketch mode until you have extruded. Otherwise, your object will not be fused with the face.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "sketch_mode_disable"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Get the plane for sketch mode.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "get_sketch_mode_plane"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Get the plane for sketch mode.",
            "type": "object",
            "properties": {
              "constraint_bound": {
                "description": "Which constraint to apply.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PathComponentConstraintBound"
                  }
                ]
              },
              "constraint_type": {
                "description": "What part of the curve should be constrained.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PathComponentConstraintType"
                  }
                ]
              },
              "object_id": {
                "description": "Which curve to constrain.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "curve_set_constraint"
                ]
              }
            },
            "required": [
              "constraint_bound",
              "constraint_type",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Sketch on some entity (e.g. a plane, a face).",
            "type": "object",
            "properties": {
              "adjust_camera": {
                "description": "Should the camera move at all?",
                "type": "boolean"
              },
              "animated": {
                "description": "Should we animate or snap for the camera transition?",
                "type": "boolean"
              },
              "entity_id": {
                "description": "Which entity to sketch on.",
                "type": "string",
                "format": "uuid"
              },
              "ortho": {
                "description": "Should the camera use orthographic projection? In other words, should an object's size in the rendered image stay constant regardless of its distance from the camera.",
                "type": "boolean"
              },
              "planar_normal": {
                "nullable": true,
                "description": "If provided, ensures that the normal of the sketch plane must be aligned with this supplied normal (otherwise the camera position will be used to infer the normal to point towards the viewer)",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "enable_sketch_mode"
                ]
              }
            },
            "required": [
              "adjust_camera",
              "animated",
              "entity_id",
              "ortho",
              "type"
            ]
          },
          {
            "description": "Sets whether or not changes to the scene or its objects will be done as a \"dry run\" In a dry run, successful commands won't actually change the model. This is useful for catching errors before actually making the change.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "enable_dry_run"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Sets whether or not changes to the scene or its objects will be done as a \"dry run\" In a dry run, successful commands won't actually change the model. This is useful for catching errors before actually making the change.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "disable_dry_run"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Set the background color of the scene.",
            "type": "object",
            "properties": {
              "color": {
                "description": "The color to set the background to.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Color"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "set_background_color"
                ]
              }
            },
            "required": [
              "color",
              "type"
            ]
          },
          {
            "description": "Set the properties of the tool lines for the scene.",
            "type": "object",
            "properties": {
              "color": {
                "nullable": true,
                "description": "The color to set the tool line to.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Color"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "set_current_tool_properties"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Set the default system properties used when a specific property isn't set.",
            "type": "object",
            "properties": {
              "color": {
                "nullable": true,
                "description": "The default system color.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Color"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "set_default_system_properties"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Get type of the given curve.",
            "type": "object",
            "properties": {
              "curve_id": {
                "description": "Which curve to query.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "curve_get_type"
                ]
              }
            },
            "required": [
              "curve_id",
              "type"
            ]
          },
          {
            "description": "Get control points of the given curve.",
            "type": "object",
            "properties": {
              "curve_id": {
                "description": "Which curve to query.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "curve_get_control_points"
                ]
              }
            },
            "required": [
              "curve_id",
              "type"
            ]
          },
          {
            "description": "Project an entity on to a plane.",
            "type": "object",
            "properties": {
              "entity_id": {
                "description": "Which entity to project (vertex or edge).",
                "type": "string",
                "format": "uuid"
              },
              "plane_id": {
                "description": "Which plane to project entity_id onto.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "project_entity_to_plane"
                ]
              },
              "use_plane_coords": {
                "description": "If true: the projected points are returned in the plane_id's coordinate system, else: the projected points are returned in the world coordinate system.",
                "type": "boolean"
              }
            },
            "required": [
              "entity_id",
              "plane_id",
              "type",
              "use_plane_coords"
            ]
          },
          {
            "description": "Project a list of points on to a plane.",
            "type": "object",
            "properties": {
              "plane_id": {
                "description": "The id of the plane used for the projection.",
                "type": "string",
                "format": "uuid"
              },
              "points": {
                "description": "The list of points that will be projected.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Point3d"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "project_points_to_plane"
                ]
              },
              "use_plane_coords": {
                "description": "If true: the projected points are returned in the plane_id's coordinate sysetm. else: the projected points are returned in the world coordinate system.",
                "type": "boolean"
              }
            },
            "required": [
              "plane_id",
              "points",
              "type",
              "use_plane_coords"
            ]
          },
          {
            "description": "Take a snapshot of the current view.",
            "type": "object",
            "properties": {
              "format": {
                "description": "What image format to return.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ImageFormat"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "take_snapshot"
                ]
              }
            },
            "required": [
              "format",
              "type"
            ]
          },
          {
            "description": "Add a gizmo showing the axes.",
            "type": "object",
            "properties": {
              "clobber": {
                "description": "If true, any existing drawables within the obj will be replaced (the object will be reset)",
                "type": "boolean"
              },
              "gizmo_mode": {
                "description": "If true, axes gizmo will be placed in the corner of the screen. If false, it will be placed at the origin of the scene.",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "make_axes_gizmo"
                ]
              }
            },
            "required": [
              "clobber",
              "gizmo_mode",
              "type"
            ]
          },
          {
            "description": "Query the given path.",
            "type": "object",
            "properties": {
              "path_id": {
                "description": "Which path to query",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "path_get_info"
                ]
              }
            },
            "required": [
              "path_id",
              "type"
            ]
          },
          {
            "description": "Obtain curve ids for vertex ids",
            "type": "object",
            "properties": {
              "path_id": {
                "description": "Which path to query",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "path_get_curve_uuids_for_vertices"
                ]
              },
              "vertex_ids": {
                "description": "IDs of the vertices for which to obtain curve ids from",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "required": [
              "path_id",
              "type",
              "vertex_ids"
            ]
          },
          {
            "description": "Obtain curve id by index",
            "type": "object",
            "properties": {
              "index": {
                "description": "IDs of the vertices for which to obtain curve ids from",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "path_id": {
                "description": "Which path to query",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "path_get_curve_uuid"
                ]
              }
            },
            "required": [
              "index",
              "path_id",
              "type"
            ]
          },
          {
            "description": "Obtain vertex ids for a path",
            "type": "object",
            "properties": {
              "path_id": {
                "description": "Which path to query",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "path_get_vertex_uuids"
                ]
              }
            },
            "required": [
              "path_id",
              "type"
            ]
          },
          {
            "description": "Obtain the sketch target id (if the path was drawn in sketchmode) for a path",
            "type": "object",
            "properties": {
              "path_id": {
                "description": "Which path to query",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "path_get_sketch_target_uuid"
                ]
              }
            },
            "required": [
              "path_id",
              "type"
            ]
          },
          {
            "description": "Start dragging the mouse.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "handle_mouse_drag_start"
                ]
              },
              "window": {
                "description": "The mouse position.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "type",
              "window"
            ]
          },
          {
            "description": "Continue dragging the mouse.",
            "type": "object",
            "properties": {
              "sequence": {
                "nullable": true,
                "description": "Logical timestamp. The client should increment this with every event in the current mouse drag. That way, if the events are being sent over an unordered channel, the API can ignore the older events.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "handle_mouse_drag_move"
                ]
              },
              "window": {
                "description": "The mouse position.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "type",
              "window"
            ]
          },
          {
            "description": "Stop dragging the mouse.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "handle_mouse_drag_end"
                ]
              },
              "window": {
                "description": "The mouse position.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "type",
              "window"
            ]
          },
          {
            "description": "Remove scene objects.",
            "type": "object",
            "properties": {
              "object_ids": {
                "description": "Objects to remove.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                },
                "uniqueItems": true
              },
              "type": {
                "type": "string",
                "enum": [
                  "remove_scene_objects"
                ]
              }
            },
            "required": [
              "object_ids",
              "type"
            ]
          },
          {
            "description": "Utility method. Performs both a ray cast and projection to plane-local coordinates. Returns the plane coordinates for the given window coordinates.",
            "type": "object",
            "properties": {
              "plane_id": {
                "description": "The plane you're intersecting against.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "plane_intersect_and_project"
                ]
              },
              "window": {
                "description": "Window coordinates where the ray cast should be aimed.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              }
            },
            "required": [
              "plane_id",
              "type",
              "window"
            ]
          },
          {
            "description": "Find the start and end of a curve.",
            "type": "object",
            "properties": {
              "curve_id": {
                "description": "ID of the curve being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "curve_get_end_points"
                ]
              }
            },
            "required": [
              "curve_id",
              "type"
            ]
          },
          {
            "description": "Reconfigure the stream.",
            "type": "object",
            "properties": {
              "bitrate": {
                "nullable": true,
                "description": "Video feed's constant bitrate (CBR)",
                "default": null,
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "fps": {
                "description": "Frames per second.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "height": {
                "description": "Height of the stream.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "reconfigure_stream"
                ]
              },
              "width": {
                "description": "Width of the stream.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              }
            },
            "required": [
              "fps",
              "height",
              "type",
              "width"
            ]
          },
          {
            "description": "Import files to the current model.",
            "type": "object",
            "properties": {
              "files": {
                "description": "Files to import.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImportFile"
                }
              },
              "format": {
                "description": "Input file format.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InputFormat3d"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "import_files"
                ]
              }
            },
            "required": [
              "files",
              "format",
              "type"
            ]
          },
          {
            "description": "Set the units of the scene. For all following commands, the units will be interpreted as the given units. Any previously executed commands will not be affected or have their units changed. They will remain in the units they were originally executed in.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "set_scene_units"
                ]
              },
              "unit": {
                "description": "Which units the scene uses.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitLength"
                  }
                ]
              }
            },
            "required": [
              "type",
              "unit"
            ]
          },
          {
            "description": "Get the mass of entities in the scene or the default scene.",
            "type": "object",
            "properties": {
              "entity_ids": {
                "description": "IDs of the entities to get the mass of. If this is empty, then the default scene is included in the mass.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "material_density": {
                "description": "The material density.",
                "type": "number",
                "format": "double"
              },
              "material_density_unit": {
                "description": "The material density unit.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitDensity"
                  }
                ]
              },
              "output_unit": {
                "description": "The output unit for the mass.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitMass"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "mass"
                ]
              }
            },
            "required": [
              "entity_ids",
              "material_density",
              "material_density_unit",
              "output_unit",
              "type"
            ]
          },
          {
            "description": "Get the density of entities in the scene or the default scene.",
            "type": "object",
            "properties": {
              "entity_ids": {
                "description": "IDs of the entities to get the density of. If this is empty, then the default scene is included in the density.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "material_mass": {
                "description": "The material mass.",
                "type": "number",
                "format": "double"
              },
              "material_mass_unit": {
                "description": "The material mass unit.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitMass"
                  }
                ]
              },
              "output_unit": {
                "description": "The output unit for the density.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitDensity"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "density"
                ]
              }
            },
            "required": [
              "entity_ids",
              "material_mass",
              "material_mass_unit",
              "output_unit",
              "type"
            ]
          },
          {
            "description": "Get the volume of entities in the scene or the default scene.",
            "type": "object",
            "properties": {
              "entity_ids": {
                "description": "IDs of the entities to get the volume of. If this is empty, then the default scene is included in the volume.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "output_unit": {
                "description": "The output unit for the volume.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitVolume"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "volume"
                ]
              }
            },
            "required": [
              "entity_ids",
              "output_unit",
              "type"
            ]
          },
          {
            "description": "Get the center of mass of entities in the scene or the default scene.",
            "type": "object",
            "properties": {
              "entity_ids": {
                "description": "IDs of the entities to get the center of mass of. If this is empty, then the default scene is included in the center of mass.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "output_unit": {
                "description": "The output unit for the center of mass.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitLength"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "center_of_mass"
                ]
              }
            },
            "required": [
              "entity_ids",
              "output_unit",
              "type"
            ]
          },
          {
            "description": "Get the surface area of entities in the scene or the default scene.",
            "type": "object",
            "properties": {
              "entity_ids": {
                "description": "IDs of the entities to get the surface area of. If this is empty, then the default scene is included in the surface area.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "output_unit": {
                "description": "The output unit for the surface area.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitArea"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "surface_area"
                ]
              }
            },
            "required": [
              "entity_ids",
              "output_unit",
              "type"
            ]
          },
          {
            "description": "Focus the default camera upon an object in the scene.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_focus_on"
                ]
              },
              "uuid": {
                "description": "UUID of object to focus on.",
                "type": "string",
                "format": "uuid"
              }
            },
            "required": [
              "type",
              "uuid"
            ]
          },
          {
            "description": "When you select some entity with the current tool, what should happen to the entity?",
            "type": "object",
            "properties": {
              "selection_type": {
                "description": "What type of selection should occur when you select something?",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SceneSelectionType"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "set_selection_type"
                ]
              }
            },
            "required": [
              "selection_type",
              "type"
            ]
          },
          {
            "description": "What kind of entities can be selected?",
            "type": "object",
            "properties": {
              "filter": {
                "description": "If vector is empty, clear all filters. If vector is non-empty, only the given entity types will be selectable.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/EntityType"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "set_selection_filter"
                ]
              }
            },
            "required": [
              "filter",
              "type"
            ]
          },
          {
            "description": "Get the ids of a given entity type.",
            "type": "object",
            "properties": {
              "filter": {
                "description": "The entity types to be queried.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/EntityType"
                }
              },
              "skip": {
                "description": "Skip the first n returned ids. If multiple filters are provided, this skip will apply to each filter individually.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "take": {
                "description": "Take n ids after any ids skipped. This value must be greater than zero and not exceed 1000. If multiple filters are provided, this take will apply to each filter individually. If there are fewer than `take` items of the provided filter type then the returned list's length will be the smaller value.",
                "type": "integer",
                "format": "uint32",
                "minimum": 1,
                "maximum": 1000
              },
              "type": {
                "type": "string",
                "enum": [
                  "scene_get_entity_ids"
                ]
              }
            },
            "required": [
              "filter",
              "skip",
              "take",
              "type"
            ]
          },
          {
            "description": "Use orthographic projection.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_set_orthographic"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Use perspective projection.",
            "type": "object",
            "properties": {
              "parameters": {
                "nullable": true,
                "description": "If this is not given, use the same parameters as last time the perspective camera was used.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PerspectiveCameraParameters"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_set_perspective"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Updates the camera to center to the center of the current selection (or the origin if nothing is selected)",
            "type": "object",
            "properties": {
              "camera_movement": {
                "description": "Dictates whether or not the camera position should be adjusted during this operation If no movement is requested, the camera will orbit around the new center from its current position",
                "default": "vantage",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CameraMovement"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_center_to_selection"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Updates the camera to center to the center of the current scene's bounds",
            "type": "object",
            "properties": {
              "camera_movement": {
                "description": "Dictates whether or not the camera position should be adjusted during this operation If no movement is requested, the camera will orbit around the new center from its current position",
                "default": "vantage",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CameraMovement"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "default_camera_center_to_scene"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Sets the default backface color used if a specific color is not set",
            "type": "object",
            "properties": {
              "backface_color": {
                "description": "The default color to use for all backfaces",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Color"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "set_default_backface_color"
                ]
              }
            },
            "required": [
              "backface_color",
              "type"
            ]
          },
          {
            "description": "Fit the view to the specified object(s).",
            "type": "object",
            "properties": {
              "animated": {
                "description": "Whether or not to animate the camera movement.",
                "default": false,
                "type": "boolean"
              },
              "object_ids": {
                "description": "Which objects to fit camera to; if empty, fit to all non-default objects. Defaults to empty vector.",
                "default": [],
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "padding": {
                "description": "How much to pad the view frame by, as a fraction of the object(s) bounding box size. Negative padding will crop the view of the object proportionally. e.g. padding = 0.2 means the view will span 120% of the object(s) bounding box, and padding = -0.2 means the view will span 80% of the object(s) bounding box.",
                "default": 0.0,
                "type": "number",
                "format": "float"
              },
              "type": {
                "type": "string",
                "enum": [
                  "zoom_to_fit"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Looks along the normal of the specified face (if it is planar!), and fits the view to it.",
            "type": "object",
            "properties": {
              "animated": {
                "description": "Whether or not to animate the camera movement. (Animation is currently not supported.)",
                "default": false,
                "type": "boolean"
              },
              "face_id": {
                "description": "Which face to orient camera to. If the face is not planar, no action will occur.",
                "type": "string",
                "format": "uuid"
              },
              "padding": {
                "description": "How much to pad the view frame by, as a fraction of the face bounding box size. Negative padding will crop the view of the face proportionally. e.g. padding = 0.2 means the view will span 120% of the face bounding box, and padding = -0.2 means the view will span 80% of the face bounding box.",
                "default": 0.0,
                "type": "number",
                "format": "float"
              },
              "type": {
                "type": "string",
                "enum": [
                  "orient_to_face"
                ]
              }
            },
            "required": [
              "face_id",
              "type"
            ]
          },
          {
            "description": "Fit the view to the scene with an isometric view.",
            "type": "object",
            "properties": {
              "padding": {
                "description": "How much to pad the view frame by, as a fraction of the object(s) bounding box size. Negative padding will crop the view of the object proportionally. e.g. padding = 0.2 means the view will span 120% of the object(s) bounding box, and padding = -0.2 means the view will span 80% of the object(s) bounding box.",
                "default": 0.0,
                "type": "number",
                "format": "float"
              },
              "type": {
                "type": "string",
                "enum": [
                  "view_isometric"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Get a concise description of all of an extrusion's faces.",
            "type": "object",
            "properties": {
              "edge_id": {
                "description": "Any edge that lies on the extrusion base path.",
                "type": "string",
                "format": "uuid"
              },
              "object_id": {
                "description": "The Solid3d object whose extrusion is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_get_extrusion_face_info"
                ]
              }
            },
            "required": [
              "edge_id",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Get a concise description of all of solids edges.",
            "type": "object",
            "properties": {
              "edge_id": {
                "description": "Any edge that lies on the extrusion base path.",
                "type": "string",
                "format": "uuid"
              },
              "object_id": {
                "description": "The Solid3d object whose info is being queried.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "solid3d_get_adjacency_info"
                ]
              }
            },
            "required": [
              "edge_id",
              "object_id",
              "type"
            ]
          },
          {
            "description": "Clear the selection",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "select_clear"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Find all IDs of selected entities",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "select_get"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Get the number of objects in the scene",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "get_num_objects"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Set the transform of an object.",
            "type": "object",
            "properties": {
              "object_id": {
                "description": "Id of the object whose transform is to be set.",
                "type": "string",
                "format": "uuid"
              },
              "transforms": {
                "description": "List of transforms to be applied to the object.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ComponentTransform"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "set_object_transform"
                ]
              }
            },
            "required": [
              "object_id",
              "transforms",
              "type"
            ]
          },
          {
            "description": "Create a new solid from combining other smaller solids. In other words, every part of the input solids will be included in the output solid.",
            "type": "object",
            "properties": {
              "solid_ids": {
                "description": "Which solids to union together. Cannot be empty.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "tolerance": {
                "description": "The maximum acceptable surface gap computed between the joined solids. Must be positive (i.e. greater than zero).",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "boolean_union"
                ]
              }
            },
            "required": [
              "solid_ids",
              "tolerance",
              "type"
            ]
          },
          {
            "description": "Create a new solid from intersecting several other solids. In other words, the part of the input solids where they all overlap will be the output solid.",
            "type": "object",
            "properties": {
              "solid_ids": {
                "description": "Which solids to intersect together",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "tolerance": {
                "description": "The maximum acceptable surface gap computed between the joined solids. Must be positive (i.e. greater than zero).",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "boolean_intersection"
                ]
              }
            },
            "required": [
              "solid_ids",
              "tolerance",
              "type"
            ]
          },
          {
            "description": "Create a new solid from subtracting several other solids. The 'target' is what will be cut from. The 'tool' is what will be cut out from 'target'.",
            "type": "object",
            "properties": {
              "target_ids": {
                "description": "Geometry to cut out from.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "tolerance": {
                "description": "The maximum acceptable surface gap computed between the target and the solids cut out from it. Must be positive (i.e. greater than zero).",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "tool_ids": {
                "description": "Will be cut out from the 'target'.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "boolean_subtract"
                ]
              }
            },
            "required": [
              "target_ids",
              "tolerance",
              "tool_ids",
              "type"
            ]
          },
          {
            "description": "Make a new path by offsetting an object by a given distance. The new path's ID will be the ID of this command.",
            "type": "object",
            "properties": {
              "face_id": {
                "nullable": true,
                "description": "If the object is a solid, this is the ID of the face to base the offset on. If given, and `object_id` refers to a solid, then this face on the solid will be offset. If given but `object_id` doesn't refer to a solid, responds with an error. If not given, then `object_id` itself will be offset directly.",
                "default": null,
                "type": "string",
                "format": "uuid"
              },
              "object_id": {
                "description": "The object that will be offset (can be a path, sketch, or a solid)",
                "type": "string",
                "format": "uuid"
              },
              "offset": {
                "description": "The distance to offset the path (positive for outset, negative for inset)",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "make_offset_path"
                ]
              }
            },
            "required": [
              "object_id",
              "offset",
              "type"
            ]
          },
          {
            "description": "Add a hole to a closed path by offsetting it a uniform distance inward.",
            "type": "object",
            "properties": {
              "object_id": {
                "description": "The closed path to add a hole to.",
                "type": "string",
                "format": "uuid"
              },
              "offset": {
                "description": "The distance to offset the path (positive for outset, negative for inset)",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "add_hole_from_offset"
                ]
              }
            },
            "required": [
              "object_id",
              "offset",
              "type"
            ]
          },
          {
            "description": "Align the grid with a plane or a planar face.",
            "type": "object",
            "properties": {
              "grid_id": {
                "description": "The grid to be moved.",
                "type": "string",
                "format": "uuid"
              },
              "reference_id": {
                "description": "The plane or face that the grid will be aligned to. If a face, it must be planar to succeed.",
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "set_grid_reference_plane"
                ]
              }
            },
            "required": [
              "grid_id",
              "reference_id",
              "type"
            ]
          },
          {
            "description": "Set the scale of the grid lines in the video feed.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "set_grid_scale"
                ]
              },
              "units": {
                "description": "Which units the `value` field uses.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitLength"
                  }
                ]
              },
              "value": {
                "description": "Distance between grid lines represents this much distance.",
                "type": "number",
                "format": "float"
              }
            },
            "required": [
              "type",
              "units",
              "value"
            ]
          },
          {
            "description": "Set the grid lines to auto scale. The grid will get larger the further you zoom out, and smaller the more you zoom in.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "set_grid_auto_scale"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Render transparent surfaces more accurately, but this might make rendering slower. Because it can interfere with runtime performance, it defaults to false.",
            "type": "object",
            "properties": {
              "enabled": {
                "nullable": true,
                "description": "Enables or disables OIT. If not given, toggles it.",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "set_order_independent_transparency"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "ModelingCmdId": {
        "description": "All commands have unique IDs. These should be randomly generated.",
        "type": "string",
        "format": "uuid"
      },
      "ModelingCmdReq": {
        "description": "A graphics command submitted to the KittyCAD engine via the Modeling API.",
        "type": "object",
        "properties": {
          "cmd": {
            "description": "Which command to submit to the Kittycad engine.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelingCmd"
              }
            ]
          },
          "cmd_id": {
            "description": "ID of command being submitted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelingCmdId"
              }
            ]
          }
        },
        "required": [
          "cmd",
          "cmd_id"
        ]
      },
      "OppositeForAngle": {
        "type": "string"
      },
      "OppositeForLengthUnit": {
        "type": "string"
      },
      "OriginType": {
        "description": "The type of origin",
        "oneOf": [
          {
            "description": "Local Origin (center of object bounding box).",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "local"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Global Origin (0, 0, 0).",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "global"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Custom Origin (user specified point).",
            "type": "object",
            "properties": {
              "origin": {
                "description": "Custom origin point.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "custom"
                ]
              }
            },
            "required": [
              "origin",
              "type"
            ]
          }
        ]
      },
      "OutputFormat2d": {
        "description": "Output 2D format specifier.",
        "oneOf": [
          {
            "description": "AutoCAD drawing interchange format.",
            "type": "object",
            "properties": {
              "storage": {
                "description": "Export storage.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/DxfStorage"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "dxf"
                ]
              }
            },
            "required": [
              "storage",
              "type"
            ]
          }
        ]
      },
      "OutputFormat3d": {
        "description": "Output 3D format specifier.",
        "oneOf": [
          {
            "description": "Autodesk Filmbox (FBX) format.",
            "type": "object",
            "properties": {
              "created": {
                "nullable": true,
                "description": "Timestamp override.",
                "type": "string",
                "format": "date-time"
              },
              "storage": {
                "description": "Specifies which kind of FBX will be exported.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FbxStorage"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "fbx"
                ]
              }
            },
            "required": [
              "storage",
              "type"
            ]
          },
          {
            "description": "glTF 2.0. We refer to this as glTF since that is how our customers refer to it, although by default it will be in binary format and thus technically (glb). If you prefer ASCII output, you can set that option for the export.",
            "type": "object",
            "properties": {
              "presentation": {
                "description": "Specifies how the JSON will be presented.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GltfPresentation"
                  }
                ]
              },
              "storage": {
                "description": "Specifies which kind of glTF 2.0 will be exported.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GltfStorage"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "gltf"
                ]
              }
            },
            "required": [
              "presentation",
              "storage",
              "type"
            ]
          },
          {
            "description": "Wavefront OBJ format.",
            "type": "object",
            "properties": {
              "coords": {
                "description": "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/System"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "obj"
                ]
              },
              "units": {
                "description": "Export length unit.\n\nDefaults to millimeters.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitLength"
                  }
                ]
              }
            },
            "required": [
              "coords",
              "type",
              "units"
            ]
          },
          {
            "description": "The PLY Polygon File Format.",
            "type": "object",
            "properties": {
              "coords": {
                "description": "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/System"
                  }
                ]
              },
              "selection": {
                "description": "Export selection.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Selection"
                  }
                ]
              },
              "storage": {
                "description": "The storage for the output PLY file.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PlyStorage"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "ply"
                ]
              },
              "units": {
                "description": "Export length unit.\n\nDefaults to millimeters.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitLength"
                  }
                ]
              }
            },
            "required": [
              "coords",
              "selection",
              "storage",
              "type",
              "units"
            ]
          },
          {
            "description": "ISO 10303-21 (STEP) format.",
            "type": "object",
            "properties": {
              "coords": {
                "description": "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/System"
                  }
                ]
              },
              "created": {
                "nullable": true,
                "description": "Timestamp override.",
                "type": "string",
                "format": "date-time"
              },
              "type": {
                "type": "string",
                "enum": [
                  "step"
                ]
              }
            },
            "required": [
              "coords",
              "type"
            ]
          },
          {
            "description": "*ST**ereo**L**ithography format.",
            "type": "object",
            "properties": {
              "coords": {
                "description": "Co-ordinate system of output data.\n\nDefaults to the [KittyCAD co-ordinate system].\n\n[KittyCAD co-ordinate system]: ../coord/constant.KITTYCAD.html",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/System"
                  }
                ]
              },
              "selection": {
                "description": "Export selection.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Selection"
                  }
                ]
              },
              "storage": {
                "description": "Export storage.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StlStorage"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "stl"
                ]
              },
              "units": {
                "description": "Export length unit.\n\nDefaults to millimeters.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UnitLength"
                  }
                ]
              }
            },
            "required": [
              "coords",
              "selection",
              "storage",
              "type",
              "units"
            ]
          }
        ]
      },
      "PathComponentConstraintBound": {
        "description": "The path component constraint bounds type",
        "type": "string",
        "enum": [
          "unconstrained",
          "partially_constrained",
          "fully_constrained"
        ]
      },
      "PathComponentConstraintType": {
        "description": "The path component constraint type",
        "type": "string",
        "enum": [
          "unconstrained",
          "vertical",
          "horizontal",
          "equal_length",
          "parallel",
          "angle_between"
        ]
      },
      "PathSegment": {
        "description": "A segment of a path. Paths are composed of many segments.",
        "oneOf": [
          {
            "description": "A straight line segment. Goes from the current path \"pen\" to the given endpoint.",
            "type": "object",
            "properties": {
              "end": {
                "description": "End point of the line.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "relative": {
                "description": "Whether or not this line is a relative offset",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "line"
                ]
              }
            },
            "required": [
              "end",
              "relative",
              "type"
            ]
          },
          {
            "description": "A circular arc segment. Arcs can be drawn clockwise when start > end.",
            "type": "object",
            "properties": {
              "center": {
                "description": "Center of the circle",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              },
              "end": {
                "description": "End of the arc along circle's perimeter.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "radius": {
                "description": "Radius of the circle",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "relative": {
                "description": "Whether or not this arc is a relative offset",
                "type": "boolean"
              },
              "start": {
                "description": "Start of the arc along circle's perimeter.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "arc"
                ]
              }
            },
            "required": [
              "center",
              "end",
              "radius",
              "relative",
              "start",
              "type"
            ]
          },
          {
            "description": "A cubic bezier curve segment. Start at the end of the current line, go through control point 1 and 2, then end at a given point.",
            "type": "object",
            "properties": {
              "control1": {
                "description": "First control point.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "control2": {
                "description": "Second control point.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "end": {
                "description": "Final control point.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "relative": {
                "description": "Whether or not this bezier is a relative offset",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "bezier"
                ]
              }
            },
            "required": [
              "control1",
              "control2",
              "end",
              "relative",
              "type"
            ]
          },
          {
            "description": "Adds a tangent arc from current pen position with the given radius and angle.",
            "type": "object",
            "properties": {
              "offset": {
                "description": "Offset of the arc. Negative values will arc clockwise.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "radius": {
                "description": "Radius of the arc. Not to be confused with Raiders of the Lost Ark.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "tangential_arc"
                ]
              }
            },
            "required": [
              "offset",
              "radius",
              "type"
            ]
          },
          {
            "description": "Adds a tangent arc from current pen position to the new position. Arcs will choose a clockwise or counter-clockwise direction based on the arc end position.",
            "type": "object",
            "properties": {
              "angle_snap_increment": {
                "nullable": true,
                "description": "0 will be interpreted as none/null.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "to": {
                "description": "Where the arc should end. Must lie in the same plane as the current path pen position. Must not be colinear with current path pen position.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "tangential_arc_to"
                ]
              }
            },
            "required": [
              "to",
              "type"
            ]
          },
          {
            "description": "Adds an arc from the current position that goes through the given interior point and ends at the given end position",
            "type": "object",
            "properties": {
              "end": {
                "description": "End point of the arc.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "interior": {
                "description": "Interior point of the arc.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point3d"
                  }
                ]
              },
              "relative": {
                "description": "Whether or not interior and end are relative to the previous path position",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "arc_to"
                ]
              }
            },
            "required": [
              "end",
              "interior",
              "relative",
              "type"
            ]
          },
          {
            "description": "Adds a circular involute from the current position that goes through the given end_radius and is rotated around the current point by angle.",
            "type": "object",
            "properties": {
              "angle": {
                "description": "The angle to rotate the involute by. A value of zero will produce a curve with a tangent along the x-axis at the start point of the curve.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "end_radius": {
                "description": "The involute is described between two circles, end_radius is the radius of the outer circle.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "reverse": {
                "description": "If reverse is true, the segment will start from the end of the involute, otherwise it will start from that start.",
                "type": "boolean"
              },
              "start_radius": {
                "description": "The involute is described between two circles, start_radius is the radius of the inner circle.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "circular_involute"
                ]
              }
            },
            "required": [
              "angle",
              "end_radius",
              "reverse",
              "start_radius",
              "type"
            ]
          },
          {
            "description": "Adds an elliptical arc segment.",
            "type": "object",
            "properties": {
              "center": {
                "description": "The center point of the ellipse.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              },
              "end_angle": {
                "description": "End of the path along the perimeter of the ellipse.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "major_axis": {
                "description": "Major axis of the ellipse.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              },
              "minor_radius": {
                "description": "Minor radius of the ellipse.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LengthUnit"
                  }
                ]
              },
              "start_angle": {
                "description": "Start of the path along the perimeter of the ellipse.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Angle"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "ellipse"
                ]
              }
            },
            "required": [
              "center",
              "end_angle",
              "major_axis",
              "minor_radius",
              "start_angle",
              "type"
            ]
          },
          {
            "description": "Adds a generic conic section specified by the end point, interior point and tangents at the start and end of the section.",
            "type": "object",
            "properties": {
              "end": {
                "description": "End point of the conic.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              },
              "end_tangent": {
                "description": "Tangent at the end of the conic.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              },
              "interior": {
                "description": "Interior point that lies on the conic.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              },
              "relative": {
                "description": "Whether or not the interior and end points are relative to the previous path position.",
                "type": "boolean"
              },
              "start_tangent": {
                "description": "Tangent at the start of the conic.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Point2d"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "conic_to"
                ]
              }
            },
            "required": [
              "end",
              "end_tangent",
              "interior",
              "relative",
              "start_tangent",
              "type"
            ]
          }
        ]
      },
      "PerspectiveCameraParameters": {
        "description": "Defines a perspective view.",
        "type": "object",
        "properties": {
          "fov_y": {
            "nullable": true,
            "description": "Camera frustum vertical field of view.",
            "type": "number",
            "format": "float"
          },
          "z_far": {
            "nullable": true,
            "description": "Camera frustum far plane.",
            "type": "number",
            "format": "float"
          },
          "z_near": {
            "nullable": true,
            "description": "Camera frustum near plane.",
            "type": "number",
            "format": "float"
          }
        }
      },
      "PlyStorage": {
        "description": "The storage for the output PLY file.",
        "oneOf": [
          {
            "description": "Write numbers in their ascii representation (e.g. -13, 6.28, etc.). Properties are separated by spaces and elements are separated by line breaks.",
            "type": "string",
            "enum": [
              "ascii"
            ]
          },
          {
            "description": "Encode payload as binary using little endian.",
            "type": "string",
            "enum": [
              "binary_little_endian"
            ]
          },
          {
            "description": "Encode payload as binary using big endian.",
            "type": "string",
            "enum": [
              "binary_big_endian"
            ]
          }
        ]
      },
      "Point2d": {
        "description": "A point in 2D space",
        "type": "object",
        "properties": {
          "x": {
            "$ref": "#/components/schemas/LengthUnit"
          },
          "y": {
            "$ref": "#/components/schemas/LengthUnit"
          }
        },
        "required": [
          "x",
          "y"
        ]
      },
      "Point3d": {
        "description": "A point in 3D space",
        "type": "object",
        "properties": {
          "x": {
            "$ref": "#/components/schemas/LengthUnit"
          },
          "y": {
            "$ref": "#/components/schemas/LengthUnit"
          },
          "z": {
            "$ref": "#/components/schemas/LengthUnit"
          }
        },
        "required": [
          "x",
          "y",
          "z"
        ]
      },
      "Point4d": {
        "description": "A point in homogeneous (4D) space",
        "type": "object",
        "properties": {
          "w": {
            "type": "number",
            "format": "float"
          },
          "x": {
            "type": "number",
            "format": "float"
          },
          "y": {
            "type": "number",
            "format": "float"
          },
          "z": {
            "type": "number",
            "format": "float"
          }
        },
        "required": [
          "w",
          "x",
          "y",
          "z"
        ]
      },
      "RelativeTo": {
        "description": "What is the given geometry relative to?",
        "oneOf": [
          {
            "description": "Local/relative to a position centered within the plane being sketched on",
            "type": "string",
            "enum": [
              "sketch_plane"
            ]
          },
          {
            "description": "Local/relative to the trajectory curve",
            "type": "string",
            "enum": [
              "trajectory_curve"
            ]
          }
        ]
      },
      "Rotation": {
        "description": "A rotation defined by an axis, origin of rotation, and an angle.",
        "type": "object",
        "properties": {
          "angle": {
            "description": "Rotate this far about the rotation axis. Defaults to zero (i.e. no rotation).",
            "allOf": [
              {
                "$ref": "#/components/schemas/Angle"
              }
            ]
          },
          "axis": {
            "description": "Rotation axis. Defaults to (0, 0, 1) (i.e. the Z axis).",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point3d"
              }
            ]
          },
          "origin": {
            "description": "Origin of the rotation. If one isn't provided, the object will rotate about its own bounding box center.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OriginType"
              }
            ]
          }
        },
        "required": [
          "angle",
          "axis",
          "origin"
        ]
      },
      "RtcIceCandidateInit": {
        "description": "ICECandidateInit is used to serialize ice candidates",
        "type": "object",
        "properties": {
          "candidate": {
            "description": "The candidate string associated with the object.",
            "type": "string"
          },
          "sdpMLineIndex": {
            "nullable": true,
            "description": "The index (starting at zero) of the m-line in the SDP this candidate is associated with.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          },
          "sdpMid": {
            "nullable": true,
            "description": "The identifier of the \"media stream identification\" as defined in [RFC 8841](https://tools.ietf.org/html/rfc8841).",
            "type": "string"
          },
          "usernameFragment": {
            "nullable": true,
            "description": "The username fragment (as defined in [RFC 8445](https://tools.ietf.org/html/rfc8445#section-5.2.1)) associated with the object.",
            "type": "string"
          }
        },
        "required": [
          "candidate"
        ]
      },
      "RtcSdpType": {
        "description": "SDPType describes the type of an SessionDescription.",
        "oneOf": [
          {
            "description": "Unspecified indicates that the type is unspecified.",
            "type": "string",
            "enum": [
              "unspecified"
            ]
          },
          {
            "description": "indicates that a description MUST be treated as an SDP offer.",
            "type": "string",
            "enum": [
              "offer"
            ]
          },
          {
            "description": "indicates that a description MUST be treated as an SDP answer, but not a final answer. A description used as an SDP pranswer may be applied as a response to an SDP offer, or an update to a previously sent SDP pranswer.",
            "type": "string",
            "enum": [
              "pranswer"
            ]
          },
          {
            "description": "indicates that a description MUST be treated as an SDP final answer, and the offer-answer exchange MUST be considered complete. A description used as an SDP answer may be applied as a response to an SDP offer or as an update to a previously sent SDP pranswer.",
            "type": "string",
            "enum": [
              "answer"
            ]
          },
          {
            "description": "indicates that a description MUST be treated as canceling the current SDP negotiation and moving the SDP offer and answer back to what it was in the previous stable state. Note the local or remote SDP descriptions in the previous stable state could be null if there has not yet been a successful offer-answer negotiation.",
            "type": "string",
            "enum": [
              "rollback"
            ]
          }
        ]
      },
      "RtcSessionDescription": {
        "description": "SessionDescription is used to expose local and remote session descriptions.",
        "type": "object",
        "properties": {
          "sdp": {
            "description": "SDP string.",
            "type": "string"
          },
          "type": {
            "description": "SDP type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/RtcSdpType"
              }
            ]
          }
        },
        "required": [
          "sdp",
          "type"
        ]
      },
      "SceneSelectionType": {
        "description": "The type of scene selection change",
        "oneOf": [
          {
            "description": "Replaces the selection",
            "type": "string",
            "enum": [
              "replace"
            ]
          },
          {
            "description": "Adds to the selection",
            "type": "string",
            "enum": [
              "add"
            ]
          },
          {
            "description": "Removes from the selection",
            "type": "string",
            "enum": [
              "remove"
            ]
          }
        ]
      },
      "SceneToolType": {
        "description": "The type of scene's active tool",
        "type": "string",
        "enum": [
          "camera_revolve",
          "select",
          "move",
          "sketch_line",
          "sketch_tangential_arc",
          "sketch_curve",
          "sketch_curve_mod"
        ]
      },
      "Selection": {
        "description": "Data item selection.",
        "oneOf": [
          {
            "description": "Visit the default scene.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "default_scene"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Visit the indexed scene.",
            "type": "object",
            "properties": {
              "index": {
                "description": "The index.",
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "scene_by_index"
                ]
              }
            },
            "required": [
              "index",
              "type"
            ]
          },
          {
            "description": "Visit the first scene with the given name.",
            "type": "object",
            "properties": {
              "name": {
                "description": "The name.",
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "scene_by_name"
                ]
              }
            },
            "required": [
              "name",
              "type"
            ]
          },
          {
            "description": "Visit the indexed mesh.",
            "type": "object",
            "properties": {
              "index": {
                "description": "The index.",
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "mesh_by_index"
                ]
              }
            },
            "required": [
              "index",
              "type"
            ]
          },
          {
            "description": "Visit the first mesh with the given name.",
            "type": "object",
            "properties": {
              "name": {
                "description": "The name.",
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "mesh_by_name"
                ]
              }
            },
            "required": [
              "name",
              "type"
            ]
          }
        ]
      },
      "SideFace": {
        "description": "IDs for a side face, extruded from the path of some sketch/2D shape.",
        "type": "object",
        "properties": {
          "face_id": {
            "description": "Desired ID for the resulting face.",
            "type": "string",
            "format": "uuid"
          },
          "path_id": {
            "description": "ID of the path this face is being extruded from.",
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "face_id",
          "path_id"
        ]
      },
      "StlStorage": {
        "description": "Export storage.",
        "oneOf": [
          {
            "description": "Plaintext encoding.",
            "type": "string",
            "enum": [
              "ascii"
            ]
          },
          {
            "description": "Binary STL encoding.\n\nThis is the default setting.",
            "type": "string",
            "enum": [
              "binary"
            ]
          }
        ]
      },
      "System": {
        "description": "Co-ordinate system definition.\n\nThe `up` axis must be orthogonal to the `forward` axis.\n\nSee [cglearn.eu] for background reading.\n\n[cglearn.eu](https://cglearn.eu/pub/computer-graphics/introduction-to-geometry#material-coordinate-systems-1)",
        "type": "object",
        "properties": {
          "forward": {
            "description": "Axis the front face of a model looks along.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AxisDirectionPair"
              }
            ]
          },
          "up": {
            "description": "Axis pointing up and away from a model.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AxisDirectionPair"
              }
            ]
          }
        },
        "required": [
          "forward",
          "up"
        ]
      },
      "Transform": {
        "description": "Ways to transform each solid being replicated in a repeating pattern.",
        "type": "object",
        "properties": {
          "replicate": {
            "description": "Whether to replicate the original solid in this instance.",
            "default": true,
            "type": "boolean"
          },
          "rotation": {
            "description": "Rotate the replica about the specified rotation axis and origin. Defaults to no rotation.",
            "default": {
              "axis": {
                "x": 0.0,
                "y": 0.0,
                "z": 1.0
              },
              "angle": {
                "unit": "degrees",
                "value": 0.0
              },
              "origin": {
                "type": "local"
              }
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/Rotation"
              }
            ]
          },
          "scale": {
            "description": "Scale the replica's size along each axis. Defaults to (1, 1, 1) (i.e. the same size as the original).",
            "default": {
              "x": 1.0,
              "y": 1.0,
              "z": 1.0
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/Point3d"
              }
            ]
          },
          "translate": {
            "description": "Translate the replica this far along each dimension. Defaults to zero vector (i.e. same position as the original).",
            "default": {
              "x": 0.0,
              "y": 0.0,
              "z": 0.0
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/Point3d"
              }
            ]
          }
        }
      },
      "TransformByForPoint3d": {
        "description": "How a property of an object should be transformed.",
        "type": "object",
        "properties": {
          "is_local": {
            "deprecated": true,
            "description": "If true, the transform is applied in local space. If false, the transform is applied in global space.",
            "type": "boolean"
          },
          "origin": {
            "nullable": true,
            "description": "What to use as the origin for the transformation. If not provided, will fall back to local or global origin, depending on whatever the `is_local` field was set to.",
            "default": null,
            "allOf": [
              {
                "$ref": "#/components/schemas/OriginType"
              }
            ]
          },
          "property": {
            "description": "The scale, or rotation, or translation.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point3d"
              }
            ]
          },
          "set": {
            "description": "If true, overwrite the previous value with this. If false, the previous value will be modified. E.g. when translating, `set=true` will set a new location, and `set=false` will translate the current location by the given X/Y/Z.",
            "type": "boolean"
          }
        },
        "required": [
          "is_local",
          "property",
          "set"
        ]
      },
      "TransformByForPoint4d": {
        "description": "How a property of an object should be transformed.",
        "type": "object",
        "properties": {
          "is_local": {
            "deprecated": true,
            "description": "If true, the transform is applied in local space. If false, the transform is applied in global space.",
            "type": "boolean"
          },
          "origin": {
            "nullable": true,
            "description": "What to use as the origin for the transformation. If not provided, will fall back to local or global origin, depending on whatever the `is_local` field was set to.",
            "default": null,
            "allOf": [
              {
                "$ref": "#/components/schemas/OriginType"
              }
            ]
          },
          "property": {
            "description": "The scale, or rotation, or translation.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Point4d"
              }
            ]
          },
          "set": {
            "description": "If true, overwrite the previous value with this. If false, the previous value will be modified. E.g. when translating, `set=true` will set a new location, and `set=false` will translate the current location by the given X/Y/Z.",
            "type": "boolean"
          }
        },
        "required": [
          "is_local",
          "property",
          "set"
        ]
      },
      "UnitAngle": {
        "description": "The valid types of angle formats.",
        "oneOf": [
          {
            "description": "Degrees <https://en.wikipedia.org/wiki/Degree_(angle)>",
            "type": "string",
            "enum": [
              "degrees"
            ]
          },
          {
            "description": "Radians <https://en.wikipedia.org/wiki/Radian>",
            "type": "string",
            "enum": [
              "radians"
            ]
          }
        ]
      },
      "UnitArea": {
        "description": "The valid types of area units.",
        "oneOf": [
          {
            "description": "Square centimeters <https://en.wikipedia.org/wiki/Square_centimeter>",
            "type": "string",
            "enum": [
              "cm2"
            ]
          },
          {
            "description": "Square decimeters <https://en.wikipedia.org/wiki/Square_decimeter>",
            "type": "string",
            "enum": [
              "dm2"
            ]
          },
          {
            "description": "Square feet <https://en.wikipedia.org/wiki/Square_foot>",
            "type": "string",
            "enum": [
              "ft2"
            ]
          },
          {
            "description": "Square inches <https://en.wikipedia.org/wiki/Square_inch>",
            "type": "string",
            "enum": [
              "in2"
            ]
          },
          {
            "description": "Square kilometers <https://en.wikipedia.org/wiki/Square_kilometer>",
            "type": "string",
            "enum": [
              "km2"
            ]
          },
          {
            "description": "Square meters <https://en.wikipedia.org/wiki/Square_meter>",
            "type": "string",
            "enum": [
              "m2"
            ]
          },
          {
            "description": "Square millimeters <https://en.wikipedia.org/wiki/Square_millimeter>",
            "type": "string",
            "enum": [
              "mm2"
            ]
          },
          {
            "description": "Square yards <https://en.wikipedia.org/wiki/Square_mile>",
            "type": "string",
            "enum": [
              "yd2"
            ]
          }
        ]
      },
      "UnitDensity": {
        "description": "The valid types for density units.",
        "oneOf": [
          {
            "description": "Pounds per cubic feet.",
            "type": "string",
            "enum": [
              "lb:ft3"
            ]
          },
          {
            "description": "Kilograms per cubic meter.",
            "type": "string",
            "enum": [
              "kg:m3"
            ]
          }
        ]
      },
      "UnitLength": {
        "description": "The valid types of length units.",
        "oneOf": [
          {
            "description": "Centimeters <https://en.wikipedia.org/wiki/Centimeter>",
            "type": "string",
            "enum": [
              "cm"
            ]
          },
          {
            "description": "Feet <https://en.wikipedia.org/wiki/Foot_(unit)>",
            "type": "string",
            "enum": [
              "ft"
            ]
          },
          {
            "description": "Inches <https://en.wikipedia.org/wiki/Inch>",
            "type": "string",
            "enum": [
              "in"
            ]
          },
          {
            "description": "Meters <https://en.wikipedia.org/wiki/Meter>",
            "type": "string",
            "enum": [
              "m"
            ]
          },
          {
            "description": "Millimeters <https://en.wikipedia.org/wiki/Millimeter>",
            "type": "string",
            "enum": [
              "mm"
            ]
          },
          {
            "description": "Yards <https://en.wikipedia.org/wiki/Yard>",
            "type": "string",
            "enum": [
              "yd"
            ]
          }
        ]
      },
      "UnitMass": {
        "description": "The valid types of mass units.",
        "oneOf": [
          {
            "description": "Grams <https://en.wikipedia.org/wiki/Gram>",
            "type": "string",
            "enum": [
              "g"
            ]
          },
          {
            "description": "Kilograms <https://en.wikipedia.org/wiki/Kilogram>",
            "type": "string",
            "enum": [
              "kg"
            ]
          },
          {
            "description": "Pounds <https://en.wikipedia.org/wiki/Pound_(mass)>",
            "type": "string",
            "enum": [
              "lb"
            ]
          }
        ]
      },
      "UnitVolume": {
        "description": "The valid types of volume units.",
        "oneOf": [
          {
            "description": "Cubic centimeters (cc or cm) <https://en.wikipedia.org/wiki/Cubic_centimeter>",
            "type": "string",
            "enum": [
              "cm3"
            ]
          },
          {
            "description": "Cubic feet (ft) <https://en.wikipedia.org/wiki/Cubic_foot>",
            "type": "string",
            "enum": [
              "ft3"
            ]
          },
          {
            "description": "Cubic inches (cu in or in) <https://en.wikipedia.org/wiki/Cubic_inch>",
            "type": "string",
            "enum": [
              "in3"
            ]
          },
          {
            "description": "Cubic meters (m) <https://en.wikipedia.org/wiki/Cubic_meter>",
            "type": "string",
            "enum": [
              "m3"
            ]
          },
          {
            "description": "Cubic yards (yd) <https://en.wikipedia.org/wiki/Cubic_yard>",
            "type": "string",
            "enum": [
              "yd3"
            ]
          },
          {
            "description": "US Fluid Ounces (fl oz) <https://en.wikipedia.org/wiki/Fluid_ounce>",
            "type": "string",
            "enum": [
              "usfloz"
            ]
          },
          {
            "description": "US Gallons (gal US) <https://en.wikipedia.org/wiki/Gallon>",
            "type": "string",
            "enum": [
              "usgal"
            ]
          },
          {
            "description": "Liters (l) <https://en.wikipedia.org/wiki/Litre>",
            "type": "string",
            "enum": [
              "l"
            ]
          },
          {
            "description": "Milliliters (ml) <https://en.wikipedia.org/wiki/Litre>",
            "type": "string",
            "enum": [
              "ml"
            ]
          }
        ]
      },
      "WebSocketRequest": {
        "description": "The websocket messages the server receives.",
        "oneOf": [
          {
            "description": "The trickle ICE candidate request.",
            "type": "object",
            "properties": {
              "candidate": {
                "description": "Information about the ICE candidate.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RtcIceCandidateInit"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "trickle_ice"
                ]
              }
            },
            "required": [
              "candidate",
              "type"
            ]
          },
          {
            "description": "The SDP offer request.",
            "type": "object",
            "properties": {
              "offer": {
                "description": "The session description.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RtcSessionDescription"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "sdp_offer"
                ]
              }
            },
            "required": [
              "offer",
              "type"
            ]
          },
          {
            "description": "The modeling command request.",
            "type": "object",
            "properties": {
              "cmd": {
                "description": "Which command to submit to the Kittycad engine.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmd"
                  }
                ]
              },
              "cmd_id": {
                "description": "ID of command being submitted.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "modeling_cmd_req"
                ]
              }
            },
            "required": [
              "cmd",
              "cmd_id",
              "type"
            ]
          },
          {
            "description": "A sequence of modeling requests. If any request fails, following requests will not be tried.",
            "type": "object",
            "properties": {
              "batch_id": {
                "description": "ID of batch being submitted. Each request has their own individual ModelingCmdId, but this is the ID of the overall batch.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ModelingCmdId"
                  }
                ]
              },
              "requests": {
                "description": "A sequence of modeling requests. If any request fails, following requests will not be tried.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ModelingCmdReq"
                }
              },
              "responses": {
                "description": "If false or omitted, responses to each batch command will just be Ok(()). If true, responses will be the actual response data for that modeling command.",
                "default": false,
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "modeling_cmd_batch_req"
                ]
              }
            },
            "required": [
              "batch_id",
              "requests",
              "type"
            ]
          },
          {
            "description": "The client-to-server Ping to ensure the WebSocket stays alive.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ping"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "The response to a metrics collection request from the server.",
            "type": "object",
            "properties": {
              "metrics": {
                "description": "Collected metrics from the Client's end of the engine connection.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClientMetrics"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "metrics_response"
                ]
              }
            },
            "required": [
              "metrics",
              "type"
            ]
          },
          {
            "description": "Return information about the connected instance",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "debug"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Authentication header request.",
            "type": "object",
            "properties": {
              "headers": {
                "description": "The authentication header.",
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "headers"
                ]
              }
            },
            "required": [
              "headers",
              "type"
            ]
          }
        ]
      },
      "WorldCoordinateSystem": {
        "type": "string",
        "enum": [
          "right_handed_up_z",
          "right_handed_up_y"
        ]
      }
    },
    "responses": {
      "Error": {
        "description": "Error",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Error"
            }
          }
        }
      }
    }
  }
}